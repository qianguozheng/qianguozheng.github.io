<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.16-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>钱国正博客</title>
  

<link rel="stylesheet" href="/css/monokai.css">
  <script src="/js/highlight.pack.js"></script>

  <script>hljs.initHighlightingOnLoad();</script>
  
  <link rel="stylesheet" href="https://qianguozheng.github.io/css/poole.css">
  <link rel="stylesheet" href="https://qianguozheng.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://qianguozheng.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://qianguozheng.github.io/index.xml" rel="alternate" type="application/rss+xml" title="钱国正博客" />
</head>

<body class="theme-base-08 ">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://qianguozheng.github.io/"><h1>钱国正博客</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
        <li><a href="/post/Golang-gorilla-context-doc/"> Golang gorilla context doc </a></li>
      
        <li><a href="/post/Golang-gorilla-mux/"> Golang gorilla mux </a></li>
      
        <li><a href="/post/Golang-introducing-HTTP-tracing/"> Golang introducing HTTP tracing </a></li>
      
        <li><a href="/post/Golang-recover-usage/"> Golang recover usage </a></li>
      
        <li><a href="/post/Golang-session-problem/"> Golang session problem </a></li>
      
        <li><a href="/post/hugo-deploy-as-submodule-on-github/"> hugo deploy as submodule on github </a></li>
      
    </ul>

    <p>&copy; 2017. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="https://qianguozheng.github.io/post/Golang-gorilla-context-doc/">
        Golang gorilla context doc
      </a>
    </h1>

    <span class="post-date">Thu, Feb 23, 2017</span>

    <p>翻译 github.com/gorilla/context/doc.go</p>

<p>包context存储的值在一个请求的声明周期中是共享的。</p>

<blockquote>
<p>注意：gorilla/context, 比<code>context.Context</code>诞生的早，不能很好的支持<a href="https://golang.org/pkg/net/http/#Request.WithContext"><code>http.Request.WithContext</code></a> (引入于Go1.7). 你应该只使用gorilla/context或者换到新的 <code>http.Request.Context()</code>.</p>
</blockquote>

<p>例如， 一个路由可以设置从URL中提取出来的变量， 并且程序的处理者可以访问这些值， 或者这个可以用来存储会话值在请求的最后。还有集中其他的常用方法。</p>

<p>这个想法是Brad Fitzpatrick在go-nuts的邮件列表中提出的：</p>

<pre><code>    http://groups.google.com/group/golang-nuts/msg/e2d679d303aa5d53
</code></pre>

<p>这里是基础用法： 首先定义你需要的键。 键的类型是interface{} 所以你可以存储任何类型。</p>

<p>这里我们定义一个键使用常用的int类型来必买名称冲突：</p>

<pre><code>package foo

import (
    &quot;github.com/gorilla/context&quot;
)

type key int

const MyKey key = 0
</code></pre>

<p>然后设置一个变量。 变量是绑定到http.Request对象的， 所以你需要请求的实例来设置值：</p>

<pre><code>context.Set(r, MyKey, &quot;bar&quot;)
</code></pre>

<p>程序可以后续使用你提供的键来访问变量：</p>

<pre><code>func MyHandler(w http.ResponseWriter, r *http.Request){
    // val is &quot;bar&quot;.
    val := context.Get(r, foo.MyKey)

    // returns (&quot;bar&quot;, true)
    val, ok := context.GetOk(r, foo.MyKey)
    //...
}
</code></pre>

<p>这是最基础的使用方式。 我们在下面讨论一些别的用法。</p>

<p>所有类型都可以存储在context中。强制使用一种类型， 把键变得私用，并且包裹Get() 和Set()来接受和返回特定类型的值：</p>

<pre><code>type key int

const mykey key = 0

// GetMyKey returns a value for this package from the request values.
func GetMyKey(r *http.Request) SomeType{
    if rv := context.Get(r, mykey); rv != nil {
        return rv.(SomeType)
    }
    return nil
}

// SetMyKey sets a value for this package in the request values.
func SetMyKey(r *http.Request, val SomeType){
    context.Set(r, mykey, val)
}
</code></pre>

<p>变量必须在请求的结尾清除，以删除所有存储的值。这个可以在http.Handler中做， 在请求被处理的时候。 只需要调用Clear()</p>

<pre><code>context.Clear(r)
</code></pre>

<p>&hellip;或者使用 ClearHandler(), 这个方便的包裹来一个http.Handler在请求声明周期的末尾来请求变量</p>

<p>包gorilla/mux 和gorilla/pat中的路由调用Clear()所以如果你使用他们中的一个，你不需要手动清除上下文。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://qianguozheng.github.io/post/hugo-deploy-as-submodule-on-github/">
        hugo deploy as submodule on github
      </a>
    </h1>

    <span class="post-date">Mon, Feb 20, 2017</span>

    

<p>本Blog就是基于Hugo的，由于担心这次的操作记录丢失，我特意写了这篇博客来记录如何使用这个东西。</p>

<p>首先根据文档 <a href="http://www.gohugo.io/tutorials/github-pages-blog/">gohugo</a>中的<a href="http://www.gohugo.io/tutorials/github-pages-blog/#hosting-personal-organization-pages">第二部分</a>：</p>

<p>以上文章介绍了如何部署的大概情况，按照步骤来就不会有问题的。</p>

<p>但是维护起来需要熟悉git submodule的概念与使用，我自以为用过git submodule就安心的使用起来了，可是始终不得其意。
最终还是被我搞定了。</p>

<p>首先每次下载 <a href="https://github.com/qianguozheng/blog-hugo.git">https://github.com/qianguozheng/blog-hugo.git</a> 的时候，总是没有自动更新<a href="https://github.com/qianguozheng/qianguozheng.github.io.git">子模块</a></p>

<pre><code>	git submodule update --init --recursive
</code></pre>

<p><a href="http://blog.csdn.net/wangjia55/article/details/24400501">来自</a></p>

<p>然后是执行./deploy.sh的时候没有提交子模块。</p>

<p>这个问题是我偶然发现问题的，我当时并不在master分支，而是特定的分支，导致无法提交。
所以 checkout下，提交就好了</p>

<p>整个工作流程如下：</p>

<pre><code>	git clone https://github.com/qianguozheng/blog-hugo.git
	cd blog-hugo;
	#下载子模块
	git submodule update --init --recursive
	
	cd public
	git checkout master
	cd ../
	
	#创建博客
	hugo new post/Golang-test.md
	
	#编辑博客等操作
	...
	
	#提交qianguozheng.github.io.git仓库
	./deploy.sh
	
	#提交blog-hugo仓库
	git add -A
	git commit -m &quot;Update blog&quot;
	git push origin master	

</code></pre>

<p>完美结束</p>

<h2 id="结论:792757c8b8fb721dcdc493eb4ef87719">结论</h2>

<p>不懂就多做测试，总会解决的</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://qianguozheng.github.io/post/Golang-gorilla-mux/">
        Golang gorilla mux
      </a>
    </h1>

    <span class="post-date">Mon, Feb 20, 2017</span>

    <p>翻译 github.com/gorilla/mux/doc.go</p>

<p>包mux实现了路由请求与分发。</p>

<p>mux代表“HTTP请求多路复用”。 像标准的http.ServeMux, mux.Router匹配进来的请求和一些注册的路径， 并且调用处理函数来处理匹配URL或其他条件的。 主要特色如下：</p>

<ul>
<li>请求可以基于URL主机， 路径，路径前缀， schemes, 头，请求值， HTTP方法或者特定的匹配方式。</li>
<li>URL主机可路径可以通过可选的正则表达式来匹配。</li>
<li>Registered URLs can be built, or &ldquo;reversed&rdquo;, which helps maintaining references to resources.</li>
<li>路由可以作为子路由： 子路由仅仅当父路由匹配的时候才会比对。 这种方式可以定义遗嘱路径拥有共同的条件特征，如主机，路径牵住，或者其他的重复属性。 额外的，这个优化请求匹配。</li>
<li>实现了http.Handler接口所以这个和标准的http.ServeMux兼容</li>
</ul>

<p>我们来注册一些URL路径和处理函数：</p>

<pre><code>func main(){
    r := mux.NewRouter()
    r.HandleFunc(&quot;/&quot;, HomeHandler)
    r.HandleFunc(&quot;/products&quot;, ProductsHandler)
    r.HandleFunc(&quot;/articles&quot;, ArticlesHandler)
    http.Handle(&quot;/&quot;, r)
}
</code></pre>

<p>我们注册了3个路径映射URL给处理函数。这个与http.HandleFunc()类似: 如果一个请求的URL符合路径，相应的处理函数被调用， 以(http.ResponseWriter, *http.Request)作为参数。</p>

<p>路径可以有变量。 他们定义使用这种格式 {name} 或者 {name:pattern}. 如果一个正常的表达模式未被定义， 匹配的变量将会是任何值，直到下一个斜线。例如：</p>

<pre><code>r := mux.NewRouter()
r.HandleFunc(&quot;/products/{key}&quot;, ProductHandler)
r.HandleFunc(&quot;/articles/{category}/&quot;, ArticlesCategoryHandler)
r.HandleFunc(&quot;/articles/{category}/{id:[0-9]+}&quot;, ArticleHandler)
</code></pre>

<p>组可以在模式内使用，只要没有捕捉(?:re). 例如：</p>

<pre><code>r.HandleFunc(&quot;/articles/{category}/{sort:(?:asc|desc|new)}&quot;, ArticleCategoryHandler)
</code></pre>

<p>名字可以用来创建一组路由变量的映射，可以通过调用mux.Vars()获得：</p>

<pre><code>vars := mux.Vars(request)
category := vars[&quot;category&quot;]
</code></pre>

<p>如果任何的capturing组存在， mux会panic()在解析的过程中。阻止这种情况发生，转换任何的capturing组为非capturing，例如 转换&rdquo;/{sort:(asc|desc)}&ldquo;为&rdquo;/{sort:{?:asc|dest}}&ldquo;. 这是从之前的不可预测的行为转换来的当capturing组存在的时候。</p>

<p>这就是所有你需要知道的基础。更高级的选项在下面解释。</p>

<p>路由同样可以限制一个域名或者子域名。 定义一个主机模式来匹配， 他们同样可以有变量：</p>

<pre><code>r := mux.NewRouter()
//Only matches if domain is &quot;www.example.com&quot;.
r.Host(&quot;www.example.com&quot;)
//Matches a dynamic subdomain.
r.Host(&quot;{subdomain:[a-z]+}.domain.com&quot;)
</code></pre>

<p>还有其他几种匹配可以添加，来匹配这种路径前缀：</p>

<pre><code>r.PathPrefix(&quot;/products/&quot;)
</code></pre>

<p>&hellip;或者HTTP方法</p>

<pre><code>r.Methods(&quot;GET&quot;, &quot;POST&quot;)
</code></pre>

<p>&hellip;或者 URL schemes:</p>

<pre><code>r.Schemes(&quot;https&quot;)
</code></pre>

<p>&hellip;或者 头部值</p>

<pre><code>r.Headers(&quot;X-Requested-With&quot;, &quot;XMLHttpRequest&quot;)
</code></pre>

<p>&hellip;或者 请求值</p>

<pre><code>r.Queries(&quot;key&quot;, &quot;value&quot;)
</code></pre>

<p>&hellip;或者 使用定制匹配函数</p>

<pre><code>r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool{
    return r.ProtoMajor == 0
})
</code></pre>

<p>&hellip;最终， 也可以组合几种匹配到一个路由中：</p>

<pre><code>r.HandleFunc(&quot;/products&quot;, ProductsHandler).
    Host(&quot;www.example.com&quot;).
    Methods(&quot;GET&quot;).
    Schemes(&quot;http&quot;)
</code></pre>

<p>一遍又一遍的设置同样的路径很烦人， 所以我们可以使用组来共享满足相同条件的路由：</p>

<pre><code>r := mux.NewRouter()
s := r.Host(&quot;www.example.com&quot;).Subrouter()
</code></pre>

<p>然在在路由中注册子路由：</p>

<pre><code>s.HandleFunc(&quot;/products/&quot;, ProductsHandler)
s.HandleFunc(&quot;/products/{key}&quot;, ProductHandler)
s.HandleFunc(&quot;/articles/{category}/{id:[0-9]+}&quot;, ArticleHandler)
</code></pre>

<p>以上三个URL路径只有当域名为 &ldquo;www.example.com&rdquo;时才会被测试, 因为子路有会首先被测试。这个不仅方便而且优化请求路径。你可以创建子路由结合任意树形的匹配器。</p>

<p>子路经可以用来创建域名或者路径“namespaces”: 你定义子路由在中间位置，然后其余部分可以基于子路由注册自己的路径</p>

<p>还有其他的子路由，当一个子路由有路径前缀时， 内部的路由使用它作为他们的基础：</p>

<pre><code>r := mux.NewRouter()
s := r.PathPrefix(&quot;/products&quot;).Subrouter()
//&quot;/products/&quot;
s.HandleFunc(&quot;/&quot;, ProductHandler)
// &quot;/products/{key}/&quot;
s.HandleFunc(&quot;/{key}/&quot;, ProductHandler)
// &quot;/products/{key}/details&quot;
s.HandleFunc(&quot;/{key}/details&quot;, ProductDetailsHandler)
</code></pre>

<p>注意，路径提供给PathPrefix()代表一个“掩码”： 调用PathPrefix(&ldquo;/static/&rdquo;).Handler()意味着处理函数会传递任何请求符合&rdquo;/static/*&ldquo;.这种方式很容易实现静态文件的路由。</p>

<pre><code>func main()
    var dir string
    flag.StringVar(&amp;dir, &quot;dir&quot;, &quot;.&quot;, &quot;the directory to serve files from. Defaults to the current dir&quot;)
    flag.Parse()
    r := mux.NewRouter()
    
    // This will serve files under http://localhost:8000/static/&lt;filename&gt;
    r.PathPrefix(&quot;/static/&quot;).Handler(http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(dir))))

	srv := &amp;http.Server{
		Handler:      r,
		Addr:         &quot;127.0.0.1:8000&quot;,
		// Good practice: enforce timeouts for servers you create!
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	log.Fatal(srv.ListenAndServe())
}
</code></pre>

<p>现在我们来看看如何建立注册URL。</p>

<p>路由可以是名称， 所有定义名称的路由可以有自己的URLs， 或者反转。我们定义一个名称通过调用Name()在路由上。例如：</p>

<pre><code>r := mux.NewRouter()
r.HandleFunc(&quot;/articles/{category}/{id:[0-9]+}&quot;, ArticleHandler).
Name(&quot;article&quot;)
</code></pre>

<p>建立URL,获取路由，调用URL()方法，传递一系列的键值对给路由变量。对于之前的路径，我们可以这样做：</p>

<pre><code>url, err := r.Get(&quot;article&quot;).URL(&quot;category&quot;, &quot;technology&quot;, &quot;id&quot;, &quot;42&quot;)
</code></pre>

<p>&hellip;并且结果会是url.URL带有下面的路径</p>

<pre><code>&quot;/articles/technology/42&quot;
</code></pre>

<p>这个同样对于主机变量：</p>

<pre><code>r := mux.NewRouter()
r.Host(&quot;{subdomain}.domain.com&quot;).
    Path(&quot;/articles/{category}/{id:[0-9]+}&quot;).
    HandlerFunc(ArticleHandler).
    Name(&quot;article&quot;)

// url.String() will be &quot;http://news.domain.com/articles/technology/42&quot;
url, err := r.Get(&quot;article&quot;).URL(&quot;subdomain&quot;, &quot;news&quot;,
                                 &quot;category&quot;, &quot;technology&quot;,
                                 &quot;id&quot;, &quot;42&quot;)
</code></pre>

<p>所有路由中的变量都是必须的，并且他们的值必须服务响应模式/这些需求保证生成的URL会一直符合注册路径 &ndash; 唯一例外的是那些显示定义 “build-only”路由永远都不会匹配。</p>

<p>正则支持也存在于匹配路由中的头。例如，我们可以作：</p>

<pre><code>r.HeaderRegexp(&quot;Content-Type&quot;, &quot;application/(text|json)&quot;)
</code></pre>

<p>&hellip;路由会匹配请求带有Content-Type为application/json以及application/text的。</p>

<p>同样可以为路由建立只有URL主机或者路径的路由：
使用方法URLHost()或者URLPath()替代/ 对于之前的路由，我们可以这样做：</p>

<pre><code>// &quot;http://news.domain.com/&quot;
host, err := r.Get(&quot;article&quot;).URLHost(&quot;subdomain&quot;, &quot;news&quot;)

// &quot;/articles/technology/42&quot;
path, err := r.Get(&quot;article&quot;).URLPath(&quot;category&quot;, &quot;technology&quot;, &quot;id&quot;, &quot;42&quot;)
</code></pre>

<p>如果你使用子路由， 主机和路径单独定义可以建立如下：</p>

<pre><code>r := mux.NewRouter()
s := r.Host(&quot;{subdomain}.domain.com&quot;).Subrouter()
s.Path(&quot;/articles/{category}/{id:[0-9]+}&quot;).
  HandlerFunc(ArticleHandler).
  Name(&quot;article&quot;)

// &quot;http://news.domain.com/articles/technology/42&quot;
url, err := r.Get(&quot;article&quot;).URL(&quot;subdomain&quot;, &quot;news&quot;,
                                 &quot;category&quot;, &quot;technology&quot;,
                                 &quot;id&quot;, &quot;42&quot;)
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://qianguozheng.github.io/post/Golang-session-problem/">
        Golang session problem
      </a>
    </h1>

    <span class="post-date">Sun, Feb 19, 2017</span>

    

<h1 id="golang-session-using-problem:3689b5210b345acfc0507cf19690ede1">Golang Session using problem</h1>

<p>以前从事嵌入式工作，没有做过多用户的处理，比如web服务器上后台管理人员与普通用户的区别。</p>

<p>最近自己在写一个认证服务器的简单管理功能，想优化下就增加了admin管理权限。</p>

<h2 id="初步设计:3689b5210b345acfc0507cf19690ede1">初步设计</h2>

<p>通过通过mux来管理路由。然后在访问/admin/路径下的API时需要检测是否登陆。</p>

<h2 id="实现中遇到的问题:3689b5210b345acfc0507cf19690ede1">实现中遇到的问题</h2>

<ol>
<li>mux的具体实现不知道，需要进一步了解，今后的文章要分析透彻。</li>
<li>google了很多的管理登陆的文章，发现都是需要在处理的API内部做判断登陆，这点我感觉繁琐了，增加一个中间件不就好了吗，但是怎么增加是一个问题。</li>
<li>另外一个就是session的使用中遇到的了，我明明增加了session，但是就是没有收到数据。</li>
</ol>

<h2 id="中间件验证登陆解决方案:3689b5210b345acfc0507cf19690ede1">中间件验证登陆解决方案</h2>

<p>通过mux建立路由，所有访问/admin/目录下的请求需要先验证是否登陆，即判断是否存在session。</p>

<p>只需要</p>

<pre><code>    router := mux.NewRouter()
	adminRoutes := mux.NewRouter()

	router.HandleFunc(&quot;/&quot;, index)

	adminRoutes.HandleFunc(&quot;/admin/&quot;, adminIndex)
	...
	
	router.PathPrefix(&quot;/admin&quot;).Handler(negroni.New(
		NewCheckLogin(),
		negroni.Wrap(adminRoutes),
	))
	// /account/login
	router.HandleFunc(&quot;/account/login&quot;, login)
	http.ListenAndServe(&quot;:8080&quot;, router)
</code></pre>

<p>negroni.New(New)eckLogin(),negroni.Wrap(adminRoutes)
这句是进行验证的，具体原理还是需要去研究下，目前不是非常的明白。</p>

<h2 id="session的使用比较奇怪-也是需要后续去学习领悟的地方:3689b5210b345acfc0507cf19690ede1">Session的使用比较奇怪，也是需要后续去学习领悟的地方。</h2>

<p>除go基本类型外，复杂对象结构存储必须先注册。</p>

<pre><code>import(
        &quot;encoding/gob&quot;
        &quot;github.com/gorilla/sessions&quot;
    )

    type Person struct {
        FirstName   string
        LastName    string
        Email       string
        Age         int
    }

    type M map[string]interface{}

    func init() {

        gob.Register(&amp;Person{})
        gob.Register(&amp;M{})
    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://qianguozheng.github.io/post/Golang-introducing-HTTP-tracing/">
        Golang introducing HTTP tracing
      </a>
    </h1>

    <span class="post-date">Fri, Jan 20, 2017</span>

    

<h1 id="介绍:4ce321d90e539aeedd18dbea4986007d">介绍</h1>

<p>在Go 1.7我们引入了HTTP跟踪， 用来收集HTTP客户端请求生命周期中详细信息的工作。包在net/http/httptrace. 手机的信息可以用来调试延时问题，服务监控，写适配系统等。</p>

<h1 id="http-事件:4ce321d90e539aeedd18dbea4986007d">HTTP 事件</h1>

<p>httptrace包提供了许多钩子在HTTP生命周期中收集信息。这些事件包括：</p>

<ul>
<li>Connection creation</li>
<li>Connection reuse</li>
<li>DNS lookups</li>
<li>Writing the request to the wire</li>
<li>Reading the response</li>
</ul>

<h1 id="跟踪事件:4ce321d90e539aeedd18dbea4986007d">跟踪事件</h1>

<p>你可以通过放置一个*httptrace.ClientTrace 包含钩子函数在请求的context.Context中来开启http追踪。各种http.RoundTripper实现通过查找上下文的 *httptrace.ClientTrace和调用相关的钩子函数来汇报内部事件</p>

<p>最终作用于请求的上下文，用户应该将一个 *httptrace.ClientTrace防到请求的上下文在开始请求之前。</p>

<pre><code class="language-golang">    req, _ := http.NewRequest(&quot;GET&quot;, &quot;http://example.com&quot;, nil)
    trace := &amp;httptrace.ClientTrace{
        DNSDone: func(dnsInfo httptrace.DNSDoneInfo) {
            fmt.Printf(&quot;DNS Info: %+v\n&quot;, dnsInfo)
        },
        GotConn: func(connInfo httptrace.GotConnInfo) {
            fmt.Printf(&quot;Got Conn: %+v\n&quot;, connInfo)
        },
    }
    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))
    if _, err := http.DefaultTransport.RoundTrip(req); err != nil {
        log.Fatal(err)
    }
</code></pre>

<p>在请求流程中，http.DefaultTransport会在事件发生时出发钩子。上面的程序会打印DNS信息当DNS查询完成时。同样的会打印连接信息当链接与请求主机建立连接时</p>

<h1 id="使用http-client跟踪:4ce321d90e539aeedd18dbea4986007d">使用http.Client跟踪</h1>

<p>跟踪机制设计用来跟踪单个的http.Transport.RoundTrip的声明周期事件。然而，一个客户端可以发起多个round trips来完成HTTP请求。例如，URL重定向，注册的钩子被调用多次当客户端跟踪HTTP重定向，发起多个请求。用户负责识别类似的事件在http.CLient中。下面的程序识别通过httpRoundTripper包裹识别当前的请求。</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;net/http/httptrace&quot;
)

// transport is an http.RoundTripper that keeps track of the in-flight
// request and implements hooks to report HTTP tracing events.
type transport struct {
    current *http.Request
}

// RoundTrip wraps http.DefaultTransport.RoundTrip to keep track
// of the current request.
func (t *transport) RoundTrip(req *http.Request) (*http.Response, error) {
    t.current = req
    return http.DefaultTransport.RoundTrip(req)
}

// GotConn prints whether the connection has been used previously
// for the current request.
func (t *transport) GotConn(info httptrace.GotConnInfo) {
    fmt.Printf(&quot;Connection reused for %v? %v\n&quot;, t.current.URL, info.Reused)
}

func main() {
    t := &amp;transport{}

    req, _ := http.NewRequest(&quot;GET&quot;, &quot;https://google.com&quot;, nil)
    trace := &amp;httptrace.ClientTrace{
        GotConn: t.GotConn,
    }
    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))

    client := &amp;http.Client{Transport: t}
    if _, err := client.Do(req); err != nil {
        log.Fatal(err)
    }
}
</code></pre>

<p>程序将会跟踪重定向google.com 到www.google.com并打印如下：</p>

<pre><code>Connection reused for https://google.com? false
Connection reused for https://www.google.com/? false
</code></pre>

<p>传输在net/http包支持跟踪http/1和http/2</p>

<p>如果你是一个定制的http.RoundTripper实现作者，你可以通过检查请求上下文并在相应的事件发生时触发钩子函数</p>

<h1 id="结论:4ce321d90e539aeedd18dbea4986007d">结论</h1>

<p>GO的HTTP跟踪对于那些感兴趣调试HTTP请求延时和些网络外部负载调试工具时。 通过开启这个功能，我们希望可以看到HTTP调试，性能。可视化工具来自社区例如httpstat.</p>

<p>By Jaana Burcu Dogan</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://qianguozheng.github.io/post/Golang-recover-usage/">
        Golang recover usage
      </a>
    </h1>

    <span class="post-date">Mon, Jan 16, 2017</span>

    

<h1 id="golang-panic-recover-usage:4cee95b6a0f7ad978328106e5f21d269">Golang panic recover usage</h1>

<h3 id="brief-introduction:4cee95b6a0f7ad978328106e5f21d269">Brief Introduction</h3>

<p>In golang, some abnormal case would cause program crash, but if you want it recover, you need to handle it by hand.</p>

<p>Below is the simple example of http function use recover to recover from panic caused by peer-end server crash.</p>

<pre><code class="language-go">package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;strings&quot;
    &quot;time&quot;
)

var err error

func httppost() {
    for {
        fmt.Println(&quot;Cycle...&quot;)
        defer func() {

            if r := recover(); r != nil {

                fmt.Println(&quot;Recovered in testPanic2Error&quot;, r)

                //check exactly what the panic was and create error.
                switch x := r.(type) {
                case string:
                    err = errors.New(x)
                case error:
                    err = x
                default:
                    err = errors.New(&quot;Unknow panic&quot;)
                }
            }
            fmt.Println(err)
            httppost()

        }()
        resp, err := http.Post(&quot;http://127.0.0.1/v3/api/device/vpn&quot;,
            &quot;application/x-www-form-urlencoded&quot;,
            strings.NewReader(&quot;name=qgz&quot;))

        if err != nil {
            fmt.Println(err)
        }

        resp.Body.Close()

        time.Sleep(time.Second * 5)
        fmt.Println(&quot;Cycle...&quot;)
    }
}

func main() {
    httppost()
}

</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://qianguozheng.github.io/post/welcome/">
        welcome
      </a>
    </h1>

    <span class="post-date">Sun, Jan 15, 2017</span>

    

<h1 id="welcome-to-qianguozheng-tech-blog:2cc7dc244eed4480e8b46c91e911e96b">welcome to qianguozheng tech blog.</h1>

  </div>
  
</div>
</div>

  </body>
</html>
