<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on 钱国正博客</title>
    <link>https://qianguozheng.github.io/categories/development/</link>
    <description>Recent content in Development on 钱国正博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 May 2018 17:04:44 +0800</lastBuildDate>
    <atom:link href="https://qianguozheng.github.io/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>go ethereum crypto private public key</title>
      <link>https://qianguozheng.github.io/post/go-ethereum-cypto-private-public-key/</link>
      <pubDate>Thu, 24 May 2018 17:04:44 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/go-ethereum-cypto-private-public-key/</guid>
      <description>

&lt;h3 id=&#34;1-生成ethereum地址:201e9feaaf52691e7c8e8295bf28af74&#34;&gt;1. 生成Ethereum地址：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;key, _ := crypto.GenerateKey()

address := crypto.PubkeyToAddress(key.PublicKey).Hex()

privateKey := hex.EncodeToString(key.D.Bytes())
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-根据私钥16进制恢复地址:201e9feaaf52691e7c8e8295bf28af74&#34;&gt;2. 根据私钥16进制恢复地址&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;key,_ := crypto.HexToECDSA(testPrivHex)
msg := crypto.Keccak256([]byte(&amp;quot;foo&amp;quot;))

sig, _ := crypto.Sign(msg, key)  #利用私钥对msg进行签名，同样可以通过签名的msg来恢复公钥，从而恢复地址

recoveredPub, _ := crypto.Ecrecover(msg, sig)
pubKey := crypto.ToECDSAPub(recoveredPub)
recoveredAddr := crypto.PubkeyToAddress(*pubKey)   #common.Address格式的地址
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2.1由此可见， 可以通过利用私钥签名，来推断出私钥对应的公钥，进而推断出地址。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.2 如下方式，也可以获取到公钥和地址&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;recoveredPub2,  _:= crypto.SigToPub(msg, sig)

recoveredAddr2 := crypto.PubkeyToAddress(*recoveredPub2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;** Ecrecover 和 SigToPub都可以获得公钥！！ **&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go ethereum create your own account</title>
      <link>https://qianguozheng.github.io/post/go-ethereum-create-your-own-account/</link>
      <pubDate>Wed, 23 May 2018 16:57:20 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/go-ethereum-create-your-own-account/</guid>
      <description>&lt;p&gt;最近两天一直搜索哪里有开源的Go实现的Ethereum的钱包，但是发现其实那么多的开源项目并没有
符合我想看的，兜兜转转，还是看了go-ethereum的源码，然后在stackoverflow上看到了下面的
实现，值得一试。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ethereum.stackexchange.com/questions/39900/create-ethereum-account-using-golang&#34;&gt;stackoverflow&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;github.com/ethereum/go-ethereum/crypto&amp;quot;
import &amp;quot;encoding/hex&amp;quot;
import &amp;quot;fmt&amp;quot;

func main() {
	
	//Create an account
	key, err := crypto.GenerateKey()
	if err != nil {
		fmt.Println(&amp;quot;Error: &amp;quot;, err.Error());
	}
	
	//Get the address
	address := crypto.PubkeyToAddress(key.PublicKey).Hex()
	fmt.Printf(&amp;quot;address[%d][%v]\n&amp;quot;, len(address), address);
	
	//Get the private key
	privateKey := hex.EncodeToString(key.D.Bytes())
	fmt.Printf(&amp;quot;privateKey[%d][%v]\n&amp;quot;, len(privateKey), privateKey);
	
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang iotuils devnull deserve deep thinking</title>
      <link>https://qianguozheng.github.io/post/golang-iotuils-devnull-deserve-deep-thinking/</link>
      <pubDate>Fri, 18 May 2018 14:41:06 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/golang-iotuils-devnull-deserve-deep-thinking/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://golang.org/src/io/ioutil/ioutil.go&#34;&gt;ioutils源码地址&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type devNull int


// devNull implements ReaderFrom as an optimization so io.Copy to

// ioutil.Discard can avoid doing unnecessary work.

var _ io.ReaderFrom = devNull(0)


func (devNull) Write(p []byte) (int, error) {

	return len(p), nil

}


func (devNull) WriteString(s string) (int, error) {

	return len(s), nil

}


var blackHolePool = sync.Pool{

	New: func() interface{} {

		b := make([]byte, 8192)

		return &amp;amp;b

	},

}


func (devNull) ReadFrom(r io.Reader) (n int64, err error) {

	bufp := blackHolePool.Get().(*[]byte)

	readSize := 0

	for {

		readSize, err = r.Read(*bufp)

		n += int64(readSize)

		if err != nil {

			blackHolePool.Put(bufp)

			if err == io.EOF {

				return n, nil

			}

			return

		}

	}

}


// Discard is an io.Writer on which all Write calls succeed

// without doing anything.

var Discard io.Writer = devNull(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用样例，说到底这个devNull到底有什么用呢？ 模拟一个黑洞，用来吃数据，而且黑洞是接口类型，
这个就是我能想到的仅有的解释了。&lt;/p&gt;

&lt;p&gt;说实话，我自认为对于Go的语法已经懂得的不少了，但是看到了这些package的实现，还是觉得自己
太自已为是了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var Discard io.Writer = devNull(0)&lt;/code&gt;  //这个定义以及初始化我就没这个想象力！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var _ io.ReaderFrom = devNull(0)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;//这个定义又如何理解呢？ 没有定义变量，想说明什么？ 让devNull必须实现ReadFrom方法？
//这是我能想到的唯一目的了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package main  
      
    import (  
        &amp;quot;fmt&amp;quot;  
        &amp;quot;io&amp;quot;  
        &amp;quot;io/ioutil&amp;quot;  
        &amp;quot;strings&amp;quot;  
    )  
      
    func main() {  
        a := strings.NewReader(&amp;quot;hello&amp;quot;)  
        p := make([]byte, 20)  
        io.Copy(ioutil.Discard, a)  
        ioutil.Discard.Write(p)  
        fmt.Println(p)　　　　　　//[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]  
    }  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>netfilter xt_recent</title>
      <link>https://qianguozheng.github.io/post/netfilter-xt_recent/</link>
      <pubDate>Wed, 26 Apr 2017 17:50:36 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/netfilter-xt_recent/</guid>
      <description>

&lt;h1 id=&#34;netfilter-xt-recent-module-analyze:d79594fadda94ba7baebfd50201d276f&#34;&gt;Netfilter xt_recent module analyze&lt;/h1&gt;

&lt;p&gt;xt_recent模块用来记录最近的几次请求，并对其做特定规则处理，超过的则做另外的处理。&lt;/p&gt;

&lt;p&gt;Netfilter模块有两个简单拓展模块， match, target.
match - 指的是 -m xxxx, 例如-m recent, -m tcp 等。
target - 指的是 REDIRECT, ACCEPT, DROP 等。&lt;/p&gt;

&lt;p&gt;这里分析的就是match模块。&lt;/p&gt;

&lt;p&gt;下面来分析下这个内核模块的实现，学习下如何编写Netfilter内核模块, 注意看里面的注释。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * Copyright (c) 2006 Patrick McHardy &amp;lt;kaber@trash.net&amp;gt;
 * Copyright © CC Computer Consultants GmbH, 2007 - 2008
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This is a replacement of the old ipt_recent module, which carried the
 * following copyright notice:
 *
 * Author: Stephen Frost &amp;lt;sfrost@snowman.net&amp;gt;
 * Copyright 2002-2003, Stephen Frost, 2.5.x port by laforge@netfilter.org
 */
#define pr_fmt(fmt) KBUILD_MODNAME &amp;quot;: &amp;quot; fmt
#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/ip.h&amp;gt;
#include &amp;lt;linux/ipv6.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/moduleparam.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/seq_file.h&amp;gt;
#include &amp;lt;linux/string.h&amp;gt;
#include &amp;lt;linux/ctype.h&amp;gt;
#include &amp;lt;linux/list.h&amp;gt;
#include &amp;lt;linux/random.h&amp;gt;
#include &amp;lt;linux/jhash.h&amp;gt;
#include &amp;lt;linux/bitops.h&amp;gt;
#include &amp;lt;linux/skbuff.h&amp;gt;
#include &amp;lt;linux/inet.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;linux/vmalloc.h&amp;gt;
#include &amp;lt;net/net_namespace.h&amp;gt;
#include &amp;lt;net/netns/generic.h&amp;gt;

#include &amp;lt;linux/netfilter/x_tables.h&amp;gt;
#include &amp;lt;linux/netfilter/xt_recent.h&amp;gt;

MODULE_AUTHOR(&amp;quot;Patrick McHardy &amp;lt;kaber@trash.net&amp;gt;&amp;quot;);
MODULE_AUTHOR(&amp;quot;Jan Engelhardt &amp;lt;jengelh@medozas.de&amp;gt;&amp;quot;);
MODULE_DESCRIPTION(&amp;quot;Xtables: \&amp;quot;recently-seen\&amp;quot; host matching&amp;quot;);
MODULE_LICENSE(&amp;quot;GPL&amp;quot;);
MODULE_ALIAS(&amp;quot;ipt_recent&amp;quot;);
MODULE_ALIAS(&amp;quot;ip6t_recent&amp;quot;);

static unsigned int ip_list_tot = 3000;
static unsigned int ip_pkt_list_tot = 255;
static unsigned int ip_list_hash_size = 0;
static unsigned int ip_list_perms = 0644;
static unsigned int ip_list_uid = 0;
static unsigned int ip_list_gid = 0;
module_param(ip_list_tot, uint, 0400);
module_param(ip_pkt_list_tot, uint, 0400);
module_param(ip_list_hash_size, uint, 0400);
module_param(ip_list_perms, uint, 0400);
module_param(ip_list_uid, uint, S_IRUGO | S_IWUSR);
module_param(ip_list_gid, uint, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(ip_list_tot, &amp;quot;number of IPs to remember per list&amp;quot;);
MODULE_PARM_DESC(ip_pkt_list_tot, &amp;quot;number of packets per IP address to remember (max. 255)&amp;quot;);
MODULE_PARM_DESC(ip_list_hash_size, &amp;quot;size of hash table used to look up IPs&amp;quot;);
MODULE_PARM_DESC(ip_list_perms, &amp;quot;permissions on /proc/net/xt_recent/* files&amp;quot;);
MODULE_PARM_DESC(ip_list_uid, &amp;quot;default owner of /proc/net/xt_recent/* files&amp;quot;);
MODULE_PARM_DESC(ip_list_gid, &amp;quot;default owning group of /proc/net/xt_recent/* files&amp;quot;);

struct recent_entry {
	struct list_head	list;
	struct list_head	lru_list;
	union nf_inet_addr	addr;
	u_int16_t		family;
	u_int8_t		ttl;
	u_int8_t		index;
	u_int16_t		nstamps;
	unsigned long		stamps[0];
};

struct recent_table {
	struct list_head	list;
	char			name[XT_RECENT_NAME_LEN];
	union nf_inet_addr	mask;
	unsigned int		refcnt;
	unsigned int		entries;
	struct list_head	lru_list;
	struct list_head	iphash[0];
};

struct recent_net {
	struct list_head	tables;
#ifdef CONFIG_PROC_FS
	struct proc_dir_entry	*xt_recent;
#endif
};

static int recent_net_id;
static inline struct recent_net *recent_pernet(struct net *net)
{
	return net_generic(net, recent_net_id);
}

static DEFINE_SPINLOCK(recent_lock);
static DEFINE_MUTEX(recent_mutex);

#ifdef CONFIG_PROC_FS
static const struct file_operations recent_old_fops, recent_mt_fops;
#endif

static u_int32_t hash_rnd __read_mostly;
static bool hash_rnd_inited __read_mostly;

static inline unsigned int recent_entry_hash4(const union nf_inet_addr *addr)
{
	return jhash_1word((__force u32)addr-&amp;gt;ip, hash_rnd) &amp;amp;
	       (ip_list_hash_size - 1);
}

static inline unsigned int recent_entry_hash6(const union nf_inet_addr *addr)
{
	return jhash2((u32 *)addr-&amp;gt;ip6, ARRAY_SIZE(addr-&amp;gt;ip6), hash_rnd) &amp;amp;
	       (ip_list_hash_size - 1);
}

static struct recent_entry *
recent_entry_lookup(const struct recent_table *table,
		    const union nf_inet_addr *addrp, u_int16_t family,
		    u_int8_t ttl)
{
	struct recent_entry *e;
	unsigned int h;

	if (family == NFPROTO_IPV4)
		h = recent_entry_hash4(addrp);
	else
		h = recent_entry_hash6(addrp);

	list_for_each_entry(e, &amp;amp;table-&amp;gt;iphash[h], list)
		if (e-&amp;gt;family == family &amp;amp;&amp;amp;
		    memcmp(&amp;amp;e-&amp;gt;addr, addrp, sizeof(e-&amp;gt;addr)) == 0 &amp;amp;&amp;amp;
		    (ttl == e-&amp;gt;ttl || ttl == 0 || e-&amp;gt;ttl == 0))
			return e;
	return NULL;
}

static void recent_entry_remove(struct recent_table *t, struct recent_entry *e)
{
	list_del(&amp;amp;e-&amp;gt;list);
	list_del(&amp;amp;e-&amp;gt;lru_list);
	kfree(e);
	t-&amp;gt;entries--;
}

/*
 * Drop entries with timestamps older then &#39;time&#39;.
 */
static void recent_entry_reap(struct recent_table *t, unsigned long time)
{
	struct recent_entry *e;

	/*
	 * The head of the LRU list is always the oldest entry.
	 */
	e = list_entry(t-&amp;gt;lru_list.next, struct recent_entry, lru_list);

	/*
	 * The last time stamp is the most recent.
	 */
	if (time_after(time, e-&amp;gt;stamps[e-&amp;gt;index-1]))
		recent_entry_remove(t, e);
}

static struct recent_entry *
recent_entry_init(struct recent_table *t, const union nf_inet_addr *addr,
		  u_int16_t family, u_int8_t ttl)
{
	struct recent_entry *e;

	if (t-&amp;gt;entries &amp;gt;= ip_list_tot) {
		e = list_entry(t-&amp;gt;lru_list.next, struct recent_entry, lru_list);
		recent_entry_remove(t, e);
	}
	e = kmalloc(sizeof(*e) + sizeof(e-&amp;gt;stamps[0]) * ip_pkt_list_tot,
		    GFP_ATOMIC);
	if (e == NULL)
		return NULL;
	memcpy(&amp;amp;e-&amp;gt;addr, addr, sizeof(e-&amp;gt;addr));
	e-&amp;gt;ttl       = ttl;
	e-&amp;gt;stamps[0] = jiffies;
	e-&amp;gt;nstamps   = 1;
	e-&amp;gt;index     = 1;
	e-&amp;gt;family    = family;
	//将entry加入table中，以addr计算出的hash值存储，提升查找效率
	if (family == NFPROTO_IPV4)
		list_add_tail(&amp;amp;e-&amp;gt;list, &amp;amp;t-&amp;gt;iphash[recent_entry_hash4(addr)]);
	else
		list_add_tail(&amp;amp;e-&amp;gt;list, &amp;amp;t-&amp;gt;iphash[recent_entry_hash6(addr)]);
	list_add_tail(&amp;amp;e-&amp;gt;lru_list, &amp;amp;t-&amp;gt;lru_list);
	t-&amp;gt;entries++;
	return e;
}

static void recent_entry_update(struct recent_table *t, struct recent_entry *e)
{
	e-&amp;gt;index %= ip_pkt_list_tot;
	e-&amp;gt;stamps[e-&amp;gt;index++] = jiffies;
	if (e-&amp;gt;index &amp;gt; e-&amp;gt;nstamps)
		e-&amp;gt;nstamps = e-&amp;gt;index;
	list_move_tail(&amp;amp;e-&amp;gt;lru_list, &amp;amp;t-&amp;gt;lru_list);
}

static struct recent_table *recent_table_lookup(struct recent_net *recent_net,
						const char *name)
{
	struct recent_table *t;

	list_for_each_entry(t, &amp;amp;recent_net-&amp;gt;tables, list)
		if (!strcmp(t-&amp;gt;name, name))
			return t;
	return NULL;
}

static void recent_table_flush(struct recent_table *t)
{
	struct recent_entry *e, *next;
	unsigned int i;

	for (i = 0; i &amp;lt; ip_list_hash_size; i++)
		list_for_each_entry_safe(e, next, &amp;amp;t-&amp;gt;iphash[i], list)
			recent_entry_remove(t, e);
}

// Netfilter核心匹配函数
static bool
recent_mt(const struct sk_buff *skb, struct xt_action_param *par)
{
	struct net *net = dev_net(par-&amp;gt;in ? par-&amp;gt;in : par-&amp;gt;out);
	struct recent_net *recent_net = recent_pernet(net);
	const struct xt_recent_mtinfo_v1 *info = par-&amp;gt;matchinfo;
	struct recent_table *t;
	struct recent_entry *e;
	union nf_inet_addr addr = {}, addr_mask;
	u_int8_t ttl;
	bool ret = info-&amp;gt;invert;

	if (par-&amp;gt;family == NFPROTO_IPV4) {
		const struct iphdr *iph = ip_hdr(skb);

		if (info-&amp;gt;side == XT_RECENT_DEST)
			addr.ip = iph-&amp;gt;daddr;
		else
			addr.ip = iph-&amp;gt;saddr;

		ttl = iph-&amp;gt;ttl;
	} else {
		const struct ipv6hdr *iph = ipv6_hdr(skb);

		if (info-&amp;gt;side == XT_RECENT_DEST)
			memcpy(&amp;amp;addr.in6, &amp;amp;iph-&amp;gt;daddr, sizeof(addr.in6));
		else
			memcpy(&amp;amp;addr.in6, &amp;amp;iph-&amp;gt;saddr, sizeof(addr.in6));

		ttl = iph-&amp;gt;hop_limit;
	}

	/* use TTL as seen before forwarding */
	if (par-&amp;gt;out != NULL &amp;amp;&amp;amp; skb-&amp;gt;sk == NULL)
		ttl++;

	//自旋锁
	spin_lock_bh(&amp;amp;recent_lock);
	//根据表名查找表，也就是通过--name指定的名字
	t = recent_table_lookup(recent_net, info-&amp;gt;name);

	nf_inet_addr_mask(&amp;amp;addr, &amp;amp;addr_mask, &amp;amp;t-&amp;gt;mask);

	//从表中根据地址掩码查找entry
	e = recent_entry_lookup(t, &amp;amp;addr_mask, par-&amp;gt;family,
				(info-&amp;gt;check_set &amp;amp; XT_RECENT_TTL) ? ttl : 0);
	
	//entry不存在，则初始化。
	if (e == NULL) {
		if (!(info-&amp;gt;check_set &amp;amp; XT_RECENT_SET))
			goto out;
		e = recent_entry_init(t, &amp;amp;addr_mask, par-&amp;gt;family, ttl);
		if (e == NULL)
			par-&amp;gt;hotdrop = true;
		ret = !ret;
		goto out;
	}

	//匹配配置命令是SET, REMOVE, UPDATE， CHECK还是什么，并执行相应命令
	if (info-&amp;gt;check_set &amp;amp; XT_RECENT_SET)
		ret = !ret;
	else if (info-&amp;gt;check_set &amp;amp; XT_RECENT_REMOVE) {
		recent_entry_remove(t, e);
		ret = !ret;
	} else if (info-&amp;gt;check_set &amp;amp; (XT_RECENT_CHECK | XT_RECENT_UPDATE)) {
		unsigned long time = jiffies - info-&amp;gt;seconds * HZ;
		unsigned int i, hits = 0;

		for (i = 0; i &amp;lt; e-&amp;gt;nstamps; i++) {
			//如果超过配置的seconds则继续，不超过就统计命中数，命中数超过就跳出循环
			if (info-&amp;gt;seconds &amp;amp;&amp;amp; time_after(time, e-&amp;gt;stamps[i]))
				continue;
			if (!info-&amp;gt;hit_count || ++hits &amp;gt;= info-&amp;gt;hit_count) {
				ret = !ret;
				break;
			}
		}

		/* info-&amp;gt;seconds must be non-zero */
		if (info-&amp;gt;check_set &amp;amp; XT_RECENT_REAP)
			recent_entry_reap(t, time);
	}

	//更新表中的entry
	if (info-&amp;gt;check_set &amp;amp; XT_RECENT_SET ||
	    (info-&amp;gt;check_set &amp;amp; XT_RECENT_UPDATE &amp;amp;&amp;amp; ret)) {
		recent_entry_update(t, e);
		e-&amp;gt;ttl = ttl;
	}
out:
	//解自旋锁
	spin_unlock_bh(&amp;amp;recent_lock);
	return ret;
}

static void recent_table_free(void *addr)
{
	kvfree(addr);
}

// 在通过iptables命令配置xt_recent相关功能时检查参数是否合法
static int recent_mt_check(const struct xt_mtchk_param *par,
			   const struct xt_recent_mtinfo_v1 *info)
{
	struct recent_net *recent_net = recent_pernet(par-&amp;gt;net);
	struct recent_table *t;
#ifdef CONFIG_PROC_FS
	struct proc_dir_entry *pde;
	kuid_t uid;
	kgid_t gid;
#endif
	unsigned int i;
	int ret = -EINVAL;
	size_t sz;

	if (unlikely(!hash_rnd_inited)) {
		get_random_bytes(&amp;amp;hash_rnd, sizeof(hash_rnd));
		hash_rnd_inited = true;
	}
	if (info-&amp;gt;check_set &amp;amp; ~XT_RECENT_VALID_FLAGS) {
		pr_info(&amp;quot;Unsupported user space flags (%08x)\n&amp;quot;,
			info-&amp;gt;check_set);
		return -EINVAL;
	}
	if (hweight8(info-&amp;gt;check_set &amp;amp;
		     (XT_RECENT_SET | XT_RECENT_REMOVE |
		      XT_RECENT_CHECK | XT_RECENT_UPDATE)) != 1)
		return -EINVAL;
	if ((info-&amp;gt;check_set &amp;amp; (XT_RECENT_SET | XT_RECENT_REMOVE)) &amp;amp;&amp;amp;
	    (info-&amp;gt;seconds || info-&amp;gt;hit_count ||
	    (info-&amp;gt;check_set &amp;amp; XT_RECENT_MODIFIERS)))
		return -EINVAL;
	if ((info-&amp;gt;check_set &amp;amp; XT_RECENT_REAP) &amp;amp;&amp;amp; !info-&amp;gt;seconds)
		return -EINVAL;
	if (info-&amp;gt;hit_count &amp;gt; ip_pkt_list_tot) {
		pr_info(&amp;quot;hitcount (%u) is larger than &amp;quot;
			&amp;quot;packets to be remembered (%u)\n&amp;quot;,
			info-&amp;gt;hit_count, ip_pkt_list_tot);
		return -EINVAL;
	}
	if (info-&amp;gt;name[0] == &#39;\0&#39; ||
	    strnlen(info-&amp;gt;name, XT_RECENT_NAME_LEN) == XT_RECENT_NAME_LEN)
		return -EINVAL;

	mutex_lock(&amp;amp;recent_mutex);
	t = recent_table_lookup(recent_net, info-&amp;gt;name);
	if (t != NULL) {
		t-&amp;gt;refcnt++;
		ret = 0;
		goto out;
	}

	sz = sizeof(*t) + sizeof(t-&amp;gt;iphash[0]) * ip_list_hash_size;
	if (sz &amp;lt;= PAGE_SIZE)
		t = kzalloc(sz, GFP_KERNEL);
	else
		t = vzalloc(sz);
	if (t == NULL) {
		ret = -ENOMEM;
		goto out;
	}
	t-&amp;gt;refcnt = 1;

	memcpy(&amp;amp;t-&amp;gt;mask, &amp;amp;info-&amp;gt;mask, sizeof(t-&amp;gt;mask));
	strcpy(t-&amp;gt;name, info-&amp;gt;name);
	INIT_LIST_HEAD(&amp;amp;t-&amp;gt;lru_list);
	for (i = 0; i &amp;lt; ip_list_hash_size; i++)
		INIT_LIST_HEAD(&amp;amp;t-&amp;gt;iphash[i]);
#ifdef CONFIG_PROC_FS
	uid = make_kuid(&amp;amp;init_user_ns, ip_list_uid);
	gid = make_kgid(&amp;amp;init_user_ns, ip_list_gid);
	if (!uid_valid(uid) || !gid_valid(gid)) {
		recent_table_free(t);
		ret = -EINVAL;
		goto out;
	}
	pde = proc_create_data(t-&amp;gt;name, ip_list_perms, recent_net-&amp;gt;xt_recent,
		  &amp;amp;recent_mt_fops, t);
	if (pde == NULL) {
		recent_table_free(t);
		ret = -ENOMEM;
		goto out;
	}
	proc_set_user(pde, uid, gid);
#endif
	spin_lock_bh(&amp;amp;recent_lock);
	list_add_tail(&amp;amp;t-&amp;gt;list, &amp;amp;recent_net-&amp;gt;tables);
	spin_unlock_bh(&amp;amp;recent_lock);
	ret = 0;
out:
	mutex_unlock(&amp;amp;recent_mutex);
	return ret;
}

static int recent_mt_check_v0(const struct xt_mtchk_param *par)
{
	const struct xt_recent_mtinfo_v0 *info_v0 = par-&amp;gt;matchinfo;
	struct xt_recent_mtinfo_v1 info_v1;

	/* Copy revision 0 structure to revision 1 */
	memcpy(&amp;amp;info_v1, info_v0, sizeof(struct xt_recent_mtinfo));
	/* Set default mask to ensure backward compatible behaviour */
	memset(info_v1.mask.all, 0xFF, sizeof(info_v1.mask.all));

	return recent_mt_check(par, &amp;amp;info_v1);
}

static int recent_mt_check_v1(const struct xt_mtchk_param *par)
{
	return recent_mt_check(par, par-&amp;gt;matchinfo);
}

static void recent_mt_destroy(const struct xt_mtdtor_param *par)
{
	struct recent_net *recent_net = recent_pernet(par-&amp;gt;net);
	const struct xt_recent_mtinfo_v1 *info = par-&amp;gt;matchinfo;
	struct recent_table *t;

	mutex_lock(&amp;amp;recent_mutex);
	t = recent_table_lookup(recent_net, info-&amp;gt;name);
	if (--t-&amp;gt;refcnt == 0) {
		spin_lock_bh(&amp;amp;recent_lock);
		list_del(&amp;amp;t-&amp;gt;list);
		spin_unlock_bh(&amp;amp;recent_lock);
#ifdef CONFIG_PROC_FS
		if (recent_net-&amp;gt;xt_recent != NULL)
			remove_proc_entry(t-&amp;gt;name, recent_net-&amp;gt;xt_recent);
#endif
		recent_table_flush(t);
		recent_table_free(t);
	}
	mutex_unlock(&amp;amp;recent_mutex);
}

// 下面recent_seq_xxx 这些都是/proc/net/xt_recent/ 目录下的，用于动态生成文件系统
// 跟netfilter本身没有关系，忽略。
#ifdef CONFIG_PROC_FS
struct recent_iter_state {
	const struct recent_table *table;
	unsigned int		bucket;
};

static void *recent_seq_start(struct seq_file *seq, loff_t *pos)
	__acquires(recent_lock)
{
	struct recent_iter_state *st = seq-&amp;gt;private;
	const struct recent_table *t = st-&amp;gt;table;
	struct recent_entry *e;
	loff_t p = *pos;

	spin_lock_bh(&amp;amp;recent_lock);

	for (st-&amp;gt;bucket = 0; st-&amp;gt;bucket &amp;lt; ip_list_hash_size; st-&amp;gt;bucket++)
		list_for_each_entry(e, &amp;amp;t-&amp;gt;iphash[st-&amp;gt;bucket], list)
			if (p-- == 0)
				return e;
	return NULL;
}

static void *recent_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
	struct recent_iter_state *st = seq-&amp;gt;private;
	const struct recent_table *t = st-&amp;gt;table;
	const struct recent_entry *e = v;
	const struct list_head *head = e-&amp;gt;list.next;

	while (head == &amp;amp;t-&amp;gt;iphash[st-&amp;gt;bucket]) {
		if (++st-&amp;gt;bucket &amp;gt;= ip_list_hash_size)
			return NULL;
		head = t-&amp;gt;iphash[st-&amp;gt;bucket].next;
	}
	(*pos)++;
	return list_entry(head, struct recent_entry, list);
}

static void recent_seq_stop(struct seq_file *s, void *v)
	__releases(recent_lock)
{
	spin_unlock_bh(&amp;amp;recent_lock);
}

static int recent_seq_show(struct seq_file *seq, void *v)
{
	const struct recent_entry *e = v;
	unsigned int i;

	i = (e-&amp;gt;index - 1) % ip_pkt_list_tot;
	if (e-&amp;gt;family == NFPROTO_IPV4)
		seq_printf(seq, &amp;quot;src=%pI4 ttl: %u last_seen: %lu oldest_pkt: %u&amp;quot;,
			   &amp;amp;e-&amp;gt;addr.ip, e-&amp;gt;ttl, e-&amp;gt;stamps[i], e-&amp;gt;index);
	else
		seq_printf(seq, &amp;quot;src=%pI6 ttl: %u last_seen: %lu oldest_pkt: %u&amp;quot;,
			   &amp;amp;e-&amp;gt;addr.in6, e-&amp;gt;ttl, e-&amp;gt;stamps[i], e-&amp;gt;index);
	for (i = 0; i &amp;lt; e-&amp;gt;nstamps; i++)
		seq_printf(seq, &amp;quot;%s %lu&amp;quot;, i ? &amp;quot;,&amp;quot; : &amp;quot;&amp;quot;, e-&amp;gt;stamps[i]);
	seq_printf(seq, &amp;quot;\n&amp;quot;);
	return 0;
}

static const struct seq_operations recent_seq_ops = {
	.start		= recent_seq_start,
	.next		= recent_seq_next,
	.stop		= recent_seq_stop,
	.show		= recent_seq_show,
};

static int recent_seq_open(struct inode *inode, struct file *file)
{
	struct recent_iter_state *st;

	st = __seq_open_private(file, &amp;amp;recent_seq_ops, sizeof(*st));
	if (st == NULL)
		return -ENOMEM;

	st-&amp;gt;table    = PDE_DATA(inode);
	return 0;
}

static ssize_t
recent_mt_proc_write(struct file *file, const char __user *input,
		     size_t size, loff_t *loff)
{
	struct recent_table *t = PDE_DATA(file_inode(file));
	struct recent_entry *e;
	char buf[sizeof(&amp;quot;+b335:1d35:1e55:dead:c0de:1715:5afe:c0de&amp;quot;)];
	const char *c = buf;
	union nf_inet_addr addr = {};
	u_int16_t family;
	bool add, succ;

	if (size == 0)
		return 0;
	if (size &amp;gt; sizeof(buf))
		size = sizeof(buf);
	if (copy_from_user(buf, input, size) != 0)
		return -EFAULT;

	/* Strict protocol! */
	if (*loff != 0)
		return -ESPIPE;
	switch (*c) {
	case &#39;/&#39;: /* flush table */
		spin_lock_bh(&amp;amp;recent_lock);
		recent_table_flush(t);
		spin_unlock_bh(&amp;amp;recent_lock);
		return size;
	case &#39;-&#39;: /* remove address */
		add = false;
		break;
	case &#39;+&#39;: /* add address */
		add = true;
		break;
	default:
		pr_info(&amp;quot;Need \&amp;quot;+ip\&amp;quot;, \&amp;quot;-ip\&amp;quot; or \&amp;quot;/\&amp;quot;\n&amp;quot;);
		return -EINVAL;
	}

	++c;
	--size;
	if (strnchr(c, size, &#39;:&#39;) != NULL) {
		family = NFPROTO_IPV6;
		succ   = in6_pton(c, size, (void *)&amp;amp;addr, &#39;\n&#39;, NULL);
	} else {
		family = NFPROTO_IPV4;
		succ   = in4_pton(c, size, (void *)&amp;amp;addr, &#39;\n&#39;, NULL);
	}

	if (!succ) {
		pr_info(&amp;quot;illegal address written to procfs\n&amp;quot;);
		return -EINVAL;
	}

	spin_lock_bh(&amp;amp;recent_lock);
	e = recent_entry_lookup(t, &amp;amp;addr, family, 0);
	if (e == NULL) {
		if (add)
			recent_entry_init(t, &amp;amp;addr, family, 0);
	} else {
		if (add)
			recent_entry_update(t, e);
		else
			recent_entry_remove(t, e);
	}
	spin_unlock_bh(&amp;amp;recent_lock);
	/* Note we removed one above */
	*loff += size + 1;
	return size + 1;
}

static const struct file_operations recent_mt_fops = {
	.open    = recent_seq_open,
	.read    = seq_read,
	.write   = recent_mt_proc_write,
	.release = seq_release_private,
	.owner   = THIS_MODULE,
	.llseek = seq_lseek,
};

static int __net_init recent_proc_net_init(struct net *net)
{
	struct recent_net *recent_net = recent_pernet(net);

	recent_net-&amp;gt;xt_recent = proc_mkdir(&amp;quot;xt_recent&amp;quot;, net-&amp;gt;proc_net);
	if (!recent_net-&amp;gt;xt_recent)
		return -ENOMEM;
	return 0;
}

static void __net_exit recent_proc_net_exit(struct net *net)
{
	struct recent_net *recent_net = recent_pernet(net);
	struct recent_table *t;

	/* recent_net_exit() is called before recent_mt_destroy(). Make sure
	 * that the parent xt_recent proc entry is is empty before trying to
	 * remove it.
	 */
	spin_lock_bh(&amp;amp;recent_lock);
	list_for_each_entry(t, &amp;amp;recent_net-&amp;gt;tables, list)
	        remove_proc_entry(t-&amp;gt;name, recent_net-&amp;gt;xt_recent);

	recent_net-&amp;gt;xt_recent = NULL;
	spin_unlock_bh(&amp;amp;recent_lock);

	remove_proc_entry(&amp;quot;xt_recent&amp;quot;, net-&amp;gt;proc_net);
}
#else
static inline int recent_proc_net_init(struct net *net)
{
	return 0;
}

static inline void recent_proc_net_exit(struct net *net)
{
}
#endif /* CONFIG_PROC_FS */

static int __net_init recent_net_init(struct net *net)
{
	struct recent_net *recent_net = recent_pernet(net);
	
	//初始化tables链表
	INIT_LIST_HEAD(&amp;amp;recent_net-&amp;gt;tables);
	return recent_proc_net_init(net);
}

static void __net_exit recent_net_exit(struct net *net)
{
	recent_proc_net_exit(net);
}

static struct pernet_operations recent_net_ops = {
	.init	= recent_net_init,
	.exit	= recent_net_exit,
	.id	= &amp;amp;recent_net_id,
	.size	= sizeof(struct recent_net),
};

//match模块的核心结构体
static struct xt_match recent_mt_reg[] __read_mostly = {
	{
		.name       = &amp;quot;recent&amp;quot;,
		.revision   = 0,
		.family     = NFPROTO_IPV4,
		.match      = recent_mt, //核心匹配函数，返回bool类型
		.matchsize  = sizeof(struct xt_recent_mtinfo),
		.checkentry = recent_mt_check_v0, //检查配置是否合法
		.destroy    = recent_mt_destroy,
		.me         = THIS_MODULE,
	},
	{
		.name       = &amp;quot;recent&amp;quot;,
		.revision   = 0,
		.family     = NFPROTO_IPV6,
		.match      = recent_mt,
		.matchsize  = sizeof(struct xt_recent_mtinfo),
		.checkentry = recent_mt_check_v0,
		.destroy    = recent_mt_destroy,
		.me         = THIS_MODULE,
	},
	{
		.name       = &amp;quot;recent&amp;quot;,
		.revision   = 1,
		.family     = NFPROTO_IPV4,
		.match      = recent_mt,
		.matchsize  = sizeof(struct xt_recent_mtinfo_v1),
		.checkentry = recent_mt_check_v1,
		.destroy    = recent_mt_destroy,
		.me         = THIS_MODULE,
	},
	{
		.name       = &amp;quot;recent&amp;quot;,
		.revision   = 1,
		.family     = NFPROTO_IPV6,
		.match      = recent_mt,
		.matchsize  = sizeof(struct xt_recent_mtinfo_v1),
		.checkentry = recent_mt_check_v1,
		.destroy    = recent_mt_destroy,
		.me         = THIS_MODULE,
	}
};

static int __init recent_mt_init(void)
{
	int err;

	if (!ip_list_tot || !ip_pkt_list_tot || ip_pkt_list_tot &amp;gt; 255)
		return -EINVAL;
	ip_list_hash_size = 1 &amp;lt;&amp;lt; fls(ip_list_tot);

	err = register_pernet_subsys(&amp;amp;recent_net_ops);
	if (err)
		return err;
	
	//Netfilter的匹配模块注册函数
	err = xt_register_matches(recent_mt_reg, ARRAY_SIZE(recent_mt_reg));
	if (err)
		unregister_pernet_subsys(&amp;amp;recent_net_ops);
	return err;
}

static void __exit recent_mt_exit(void)
{
	xt_unregister_matches(recent_mt_reg, ARRAY_SIZE(recent_mt_reg));
	unregister_pernet_subsys(&amp;amp;recent_net_ops);
}

module_init(recent_mt_init);
module_exit(recent_mt_exit);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存储结构为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Table(Hash Table)
    |---------- entry (ip:192.168.4.12)
    |-------- entry (ip:192.168.4.33)
    |------  
    |--------
    |---------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单理解，就是使用hash表存储每个IP地址经过的数据包数量， 每个IP代表一个entry, 也是一个链表。
所以这个结构就: 是通过hash查找特定的IP,然后遍历列表计算超时数据包和命中数是否满足，并执行相应
的target.&lt;/p&gt;

&lt;p&gt;用hash表的原因在于，IP的数量很多的时候可以直接找到IP，而不需要通过遍历整个链表，提升查找效率。&lt;/p&gt;

&lt;p&gt;使用recent模块的样例： 目的60s内单个ip匹配20个数据包连接，超过的接受，不超过的重定向到3128端口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	iptables -t nat -N SQUID
	iptables -t nat -I SQUID -p tcp --dport 80 --syn -m recent --name webpool --rcheck --seconds 60 --hitcount 20 -j ACCEPT
	iptables -t nat -I SQUID -p tcp --dport 80 --syn -m recent --name webpool --set -j REDIRECT --to-ports 3128
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux getsockopt sample usage</title>
      <link>https://qianguozheng.github.io/post/Linux-getsockopt-sample-usage/</link>
      <pubDate>Wed, 26 Apr 2017 16:24:12 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Linux-getsockopt-sample-usage/</guid>
      <description>

&lt;h1 id=&#34;linux-getsockopt-sample-usage:43cd2fcc3caa990aab8ea1183ae04ce2&#34;&gt;Linux getsockopt sample usage&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;	#include &amp;lt;linux/netfilter_ipv4.h&amp;gt; //SO_ORIGINAL_DST
	//Get the target ip and port address
	 int status;
	 socklen_t destlen;
	 struct sockaddr_in destaddr;
	 char destinationName[256];
	 int port;
	 memset(destinationName, 0, 256);
	 
	 status = getsockopt(afd, IPPROTO_IP, SO_ORIGINAL_DST, (struct sockaddr *) &amp;amp;destaddr, &amp;amp;destlen);
	 inet_ntop(AF_INET, (void *)&amp;amp;destaddr.sin_addr, destinationName, sizeof(destinationName));
	 port = ntohs(destaddr.sin_port);
	 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;这里的SO_ORIGINAL_DST是用于netfilter REDIRECT target重定向过的数据包中的。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang gorilla context doc</title>
      <link>https://qianguozheng.github.io/post/Golang-gorilla-context-doc/</link>
      <pubDate>Thu, 23 Feb 2017 17:26:24 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-gorilla-context-doc/</guid>
      <description>&lt;p&gt;翻译 github.com/gorilla/context/doc.go&lt;/p&gt;

&lt;p&gt;包context存储的值在一个请求的声明周期中是共享的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：gorilla/context, 比&lt;code&gt;context.Context&lt;/code&gt;诞生的早，不能很好的支持&lt;a href=&#34;https://golang.org/pkg/net/http/#Request.WithContext&#34;&gt;&lt;code&gt;http.Request.WithContext&lt;/code&gt;&lt;/a&gt; (引入于Go1.7). 你应该只使用gorilla/context或者换到新的 &lt;code&gt;http.Request.Context()&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如， 一个路由可以设置从URL中提取出来的变量， 并且程序的处理者可以访问这些值， 或者这个可以用来存储会话值在请求的最后。还有集中其他的常用方法。&lt;/p&gt;

&lt;p&gt;这个想法是Brad Fitzpatrick在go-nuts的邮件列表中提出的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://groups.google.com/group/golang-nuts/msg/e2d679d303aa5d53
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是基础用法： 首先定义你需要的键。 键的类型是interface{} 所以你可以存储任何类型。&lt;/p&gt;

&lt;p&gt;这里我们定义一个键使用常用的int类型来必买名称冲突：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package foo

import (
    &amp;quot;github.com/gorilla/context&amp;quot;
)

type key int

const MyKey key = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后设置一个变量。 变量是绑定到http.Request对象的， 所以你需要请求的实例来设置值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context.Set(r, MyKey, &amp;quot;bar&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序可以后续使用你提供的键来访问变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MyHandler(w http.ResponseWriter, r *http.Request){
    // val is &amp;quot;bar&amp;quot;.
    val := context.Get(r, foo.MyKey)

    // returns (&amp;quot;bar&amp;quot;, true)
    val, ok := context.GetOk(r, foo.MyKey)
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是最基础的使用方式。 我们在下面讨论一些别的用法。&lt;/p&gt;

&lt;p&gt;所有类型都可以存储在context中。强制使用一种类型， 把键变得私用，并且包裹Get() 和Set()来接受和返回特定类型的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type key int

const mykey key = 0

// GetMyKey returns a value for this package from the request values.
func GetMyKey(r *http.Request) SomeType{
    if rv := context.Get(r, mykey); rv != nil {
        return rv.(SomeType)
    }
    return nil
}

// SetMyKey sets a value for this package in the request values.
func SetMyKey(r *http.Request, val SomeType){
    context.Set(r, mykey, val)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变量必须在请求的结尾清除，以删除所有存储的值。这个可以在http.Handler中做， 在请求被处理的时候。 只需要调用Clear()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context.Clear(r)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;或者使用 ClearHandler(), 这个方便的包裹来一个http.Handler在请求声明周期的末尾来请求变量&lt;/p&gt;

&lt;p&gt;包gorilla/mux 和gorilla/pat中的路由调用Clear()所以如果你使用他们中的一个，你不需要手动清除上下文。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hugo deploy as submodule on github</title>
      <link>https://qianguozheng.github.io/post/hugo-deploy-as-submodule-on-github/</link>
      <pubDate>Mon, 20 Feb 2017 11:23:14 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/hugo-deploy-as-submodule-on-github/</guid>
      <description>

&lt;p&gt;本Blog就是基于Hugo的，由于担心这次的操作记录丢失，我特意写了这篇博客来记录如何使用这个东西。&lt;/p&gt;

&lt;p&gt;首先根据文档 &lt;a href=&#34;http://www.gohugo.io/tutorials/github-pages-blog/&#34;&gt;gohugo&lt;/a&gt;中的&lt;a href=&#34;http://www.gohugo.io/tutorials/github-pages-blog/#hosting-personal-organization-pages&#34;&gt;第二部分&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;以上文章介绍了如何部署的大概情况，按照步骤来就不会有问题的。&lt;/p&gt;

&lt;p&gt;但是维护起来需要熟悉git submodule的概念与使用，我自以为用过git submodule就安心的使用起来了，可是始终不得其意。
最终还是被我搞定了。&lt;/p&gt;

&lt;p&gt;首先每次下载 &lt;a href=&#34;https://github.com/qianguozheng/blog-hugo.git&#34;&gt;https://github.com/qianguozheng/blog-hugo.git&lt;/a&gt; 的时候，总是没有自动更新&lt;a href=&#34;https://github.com/qianguozheng/qianguozheng.github.io.git&#34;&gt;子模块&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/wangjia55/article/details/24400501&#34;&gt;来自&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后是执行./deploy.sh的时候没有提交子模块。&lt;/p&gt;

&lt;p&gt;这个问题是我偶然发现问题的，我当时并不在master分支，而是特定的分支，导致无法提交。
所以 checkout下，提交就好了&lt;/p&gt;

&lt;p&gt;整个工作流程如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	git clone https://github.com/qianguozheng/blog-hugo.git
	cd blog-hugo;
	#下载子模块
	git submodule update --init --recursive
	
	cd public
	git checkout master
	cd ../
	
	#创建博客
	hugo new post/Golang-test.md
	
	#编辑博客等操作
	...
	
	#提交qianguozheng.github.io.git仓库
	./deploy.sh
	
	#提交blog-hugo仓库
	git add -A
	git commit -m &amp;quot;Update blog&amp;quot;
	git push origin master	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完美结束&lt;/p&gt;

&lt;h2 id=&#34;结论:792757c8b8fb721dcdc493eb4ef87719&#34;&gt;结论&lt;/h2&gt;

&lt;p&gt;不懂就多做测试，总会解决的&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang gorilla mux</title>
      <link>https://qianguozheng.github.io/post/Golang-gorilla-mux/</link>
      <pubDate>Mon, 20 Feb 2017 11:03:48 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-gorilla-mux/</guid>
      <description>&lt;p&gt;翻译 github.com/gorilla/mux/doc.go&lt;/p&gt;

&lt;p&gt;包mux实现了路由请求与分发。&lt;/p&gt;

&lt;p&gt;mux代表“HTTP请求多路复用”。 像标准的http.ServeMux, mux.Router匹配进来的请求和一些注册的路径， 并且调用处理函数来处理匹配URL或其他条件的。 主要特色如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请求可以基于URL主机， 路径，路径前缀， schemes, 头，请求值， HTTP方法或者特定的匹配方式。&lt;/li&gt;
&lt;li&gt;URL主机可路径可以通过可选的正则表达式来匹配。&lt;/li&gt;
&lt;li&gt;Registered URLs can be built, or &amp;ldquo;reversed&amp;rdquo;, which helps maintaining references to resources.&lt;/li&gt;
&lt;li&gt;路由可以作为子路由： 子路由仅仅当父路由匹配的时候才会比对。 这种方式可以定义遗嘱路径拥有共同的条件特征，如主机，路径牵住，或者其他的重复属性。 额外的，这个优化请求匹配。&lt;/li&gt;
&lt;li&gt;实现了http.Handler接口所以这个和标准的http.ServeMux兼容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们来注册一些URL路径和处理函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main(){
    r := mux.NewRouter()
    r.HandleFunc(&amp;quot;/&amp;quot;, HomeHandler)
    r.HandleFunc(&amp;quot;/products&amp;quot;, ProductsHandler)
    r.HandleFunc(&amp;quot;/articles&amp;quot;, ArticlesHandler)
    http.Handle(&amp;quot;/&amp;quot;, r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们注册了3个路径映射URL给处理函数。这个与http.HandleFunc()类似: 如果一个请求的URL符合路径，相应的处理函数被调用， 以(http.ResponseWriter, *http.Request)作为参数。&lt;/p&gt;

&lt;p&gt;路径可以有变量。 他们定义使用这种格式 {name} 或者 {name:pattern}. 如果一个正常的表达模式未被定义， 匹配的变量将会是任何值，直到下一个斜线。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r := mux.NewRouter()
r.HandleFunc(&amp;quot;/products/{key}&amp;quot;, ProductHandler)
r.HandleFunc(&amp;quot;/articles/{category}/&amp;quot;, ArticlesCategoryHandler)
r.HandleFunc(&amp;quot;/articles/{category}/{id:[0-9]+}&amp;quot;, ArticleHandler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组可以在模式内使用，只要没有捕捉(?:re). 例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.HandleFunc(&amp;quot;/articles/{category}/{sort:(?:asc|desc|new)}&amp;quot;, ArticleCategoryHandler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;名字可以用来创建一组路由变量的映射，可以通过调用mux.Vars()获得：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vars := mux.Vars(request)
category := vars[&amp;quot;category&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果任何的capturing组存在， mux会panic()在解析的过程中。阻止这种情况发生，转换任何的capturing组为非capturing，例如 转换&amp;rdquo;/{sort:(asc|desc)}&amp;ldquo;为&amp;rdquo;/{sort:{?:asc|dest}}&amp;ldquo;. 这是从之前的不可预测的行为转换来的当capturing组存在的时候。&lt;/p&gt;

&lt;p&gt;这就是所有你需要知道的基础。更高级的选项在下面解释。&lt;/p&gt;

&lt;p&gt;路由同样可以限制一个域名或者子域名。 定义一个主机模式来匹配， 他们同样可以有变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r := mux.NewRouter()
//Only matches if domain is &amp;quot;www.example.com&amp;quot;.
r.Host(&amp;quot;www.example.com&amp;quot;)
//Matches a dynamic subdomain.
r.Host(&amp;quot;{subdomain:[a-z]+}.domain.com&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有其他几种匹配可以添加，来匹配这种路径前缀：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.PathPrefix(&amp;quot;/products/&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;或者HTTP方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.Methods(&amp;quot;GET&amp;quot;, &amp;quot;POST&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;或者 URL schemes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.Schemes(&amp;quot;https&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;或者 头部值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.Headers(&amp;quot;X-Requested-With&amp;quot;, &amp;quot;XMLHttpRequest&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;或者 请求值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.Queries(&amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;或者 使用定制匹配函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool{
    return r.ProtoMajor == 0
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;最终， 也可以组合几种匹配到一个路由中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.HandleFunc(&amp;quot;/products&amp;quot;, ProductsHandler).
    Host(&amp;quot;www.example.com&amp;quot;).
    Methods(&amp;quot;GET&amp;quot;).
    Schemes(&amp;quot;http&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一遍又一遍的设置同样的路径很烦人， 所以我们可以使用组来共享满足相同条件的路由：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r := mux.NewRouter()
s := r.Host(&amp;quot;www.example.com&amp;quot;).Subrouter()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然在在路由中注册子路由：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.HandleFunc(&amp;quot;/products/&amp;quot;, ProductsHandler)
s.HandleFunc(&amp;quot;/products/{key}&amp;quot;, ProductHandler)
s.HandleFunc(&amp;quot;/articles/{category}/{id:[0-9]+}&amp;quot;, ArticleHandler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上三个URL路径只有当域名为 &amp;ldquo;www.example.com&amp;rdquo;时才会被测试, 因为子路有会首先被测试。这个不仅方便而且优化请求路径。你可以创建子路由结合任意树形的匹配器。&lt;/p&gt;

&lt;p&gt;子路经可以用来创建域名或者路径“namespaces”: 你定义子路由在中间位置，然后其余部分可以基于子路由注册自己的路径&lt;/p&gt;

&lt;p&gt;还有其他的子路由，当一个子路由有路径前缀时， 内部的路由使用它作为他们的基础：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r := mux.NewRouter()
s := r.PathPrefix(&amp;quot;/products&amp;quot;).Subrouter()
//&amp;quot;/products/&amp;quot;
s.HandleFunc(&amp;quot;/&amp;quot;, ProductHandler)
// &amp;quot;/products/{key}/&amp;quot;
s.HandleFunc(&amp;quot;/{key}/&amp;quot;, ProductHandler)
// &amp;quot;/products/{key}/details&amp;quot;
s.HandleFunc(&amp;quot;/{key}/details&amp;quot;, ProductDetailsHandler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，路径提供给PathPrefix()代表一个“掩码”： 调用PathPrefix(&amp;ldquo;/static/&amp;rdquo;).Handler()意味着处理函数会传递任何请求符合&amp;rdquo;/static/*&amp;ldquo;.这种方式很容易实现静态文件的路由。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main()
    var dir string
    flag.StringVar(&amp;amp;dir, &amp;quot;dir&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;the directory to serve files from. Defaults to the current dir&amp;quot;)
    flag.Parse()
    r := mux.NewRouter()
    
    // This will serve files under http://localhost:8000/static/&amp;lt;filename&amp;gt;
    r.PathPrefix(&amp;quot;/static/&amp;quot;).Handler(http.StripPrefix(&amp;quot;/static/&amp;quot;, http.FileServer(http.Dir(dir))))

	srv := &amp;amp;http.Server{
		Handler:      r,
		Addr:         &amp;quot;127.0.0.1:8000&amp;quot;,
		// Good practice: enforce timeouts for servers you create!
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	log.Fatal(srv.ListenAndServe())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们来看看如何建立注册URL。&lt;/p&gt;

&lt;p&gt;路由可以是名称， 所有定义名称的路由可以有自己的URLs， 或者反转。我们定义一个名称通过调用Name()在路由上。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r := mux.NewRouter()
r.HandleFunc(&amp;quot;/articles/{category}/{id:[0-9]+}&amp;quot;, ArticleHandler).
Name(&amp;quot;article&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建立URL,获取路由，调用URL()方法，传递一系列的键值对给路由变量。对于之前的路径，我们可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;url, err := r.Get(&amp;quot;article&amp;quot;).URL(&amp;quot;category&amp;quot;, &amp;quot;technology&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;42&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;并且结果会是url.URL带有下面的路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;/articles/technology/42&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个同样对于主机变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r := mux.NewRouter()
r.Host(&amp;quot;{subdomain}.domain.com&amp;quot;).
    Path(&amp;quot;/articles/{category}/{id:[0-9]+}&amp;quot;).
    HandlerFunc(ArticleHandler).
    Name(&amp;quot;article&amp;quot;)

// url.String() will be &amp;quot;http://news.domain.com/articles/technology/42&amp;quot;
url, err := r.Get(&amp;quot;article&amp;quot;).URL(&amp;quot;subdomain&amp;quot;, &amp;quot;news&amp;quot;,
                                 &amp;quot;category&amp;quot;, &amp;quot;technology&amp;quot;,
                                 &amp;quot;id&amp;quot;, &amp;quot;42&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有路由中的变量都是必须的，并且他们的值必须服务响应模式/这些需求保证生成的URL会一直符合注册路径 &amp;ndash; 唯一例外的是那些显示定义 “build-only”路由永远都不会匹配。&lt;/p&gt;

&lt;p&gt;正则支持也存在于匹配路由中的头。例如，我们可以作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r.HeaderRegexp(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/(text|json)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;路由会匹配请求带有Content-Type为application/json以及application/text的。&lt;/p&gt;

&lt;p&gt;同样可以为路由建立只有URL主机或者路径的路由：
使用方法URLHost()或者URLPath()替代/ 对于之前的路由，我们可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// &amp;quot;http://news.domain.com/&amp;quot;
host, err := r.Get(&amp;quot;article&amp;quot;).URLHost(&amp;quot;subdomain&amp;quot;, &amp;quot;news&amp;quot;)

// &amp;quot;/articles/technology/42&amp;quot;
path, err := r.Get(&amp;quot;article&amp;quot;).URLPath(&amp;quot;category&amp;quot;, &amp;quot;technology&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;42&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用子路由， 主机和路径单独定义可以建立如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r := mux.NewRouter()
s := r.Host(&amp;quot;{subdomain}.domain.com&amp;quot;).Subrouter()
s.Path(&amp;quot;/articles/{category}/{id:[0-9]+}&amp;quot;).
  HandlerFunc(ArticleHandler).
  Name(&amp;quot;article&amp;quot;)

// &amp;quot;http://news.domain.com/articles/technology/42&amp;quot;
url, err := r.Get(&amp;quot;article&amp;quot;).URL(&amp;quot;subdomain&amp;quot;, &amp;quot;news&amp;quot;,
                                 &amp;quot;category&amp;quot;, &amp;quot;technology&amp;quot;,
                                 &amp;quot;id&amp;quot;, &amp;quot;42&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang session problem</title>
      <link>https://qianguozheng.github.io/post/Golang-session-problem/</link>
      <pubDate>Sun, 19 Feb 2017 21:03:06 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-session-problem/</guid>
      <description>

&lt;h1 id=&#34;golang-session-using-problem:3689b5210b345acfc0507cf19690ede1&#34;&gt;Golang Session using problem&lt;/h1&gt;

&lt;p&gt;以前从事嵌入式工作，没有做过多用户的处理，比如web服务器上后台管理人员与普通用户的区别。&lt;/p&gt;

&lt;p&gt;最近自己在写一个认证服务器的简单管理功能，想优化下就增加了admin管理权限。&lt;/p&gt;

&lt;h2 id=&#34;初步设计:3689b5210b345acfc0507cf19690ede1&#34;&gt;初步设计&lt;/h2&gt;

&lt;p&gt;通过通过mux来管理路由。然后在访问/admin/路径下的API时需要检测是否登陆。&lt;/p&gt;

&lt;h2 id=&#34;实现中遇到的问题:3689b5210b345acfc0507cf19690ede1&#34;&gt;实现中遇到的问题&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;mux的具体实现不知道，需要进一步了解，今后的文章要分析透彻。&lt;/li&gt;
&lt;li&gt;google了很多的管理登陆的文章，发现都是需要在处理的API内部做判断登陆，这点我感觉繁琐了，增加一个中间件不就好了吗，但是怎么增加是一个问题。&lt;/li&gt;
&lt;li&gt;另外一个就是session的使用中遇到的了，我明明增加了session，但是就是没有收到数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;中间件验证登陆解决方案:3689b5210b345acfc0507cf19690ede1&#34;&gt;中间件验证登陆解决方案&lt;/h2&gt;

&lt;p&gt;通过mux建立路由，所有访问/admin/目录下的请求需要先验证是否登陆，即判断是否存在session。&lt;/p&gt;

&lt;p&gt;只需要&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    router := mux.NewRouter()
	adminRoutes := mux.NewRouter()

	router.HandleFunc(&amp;quot;/&amp;quot;, index)

	adminRoutes.HandleFunc(&amp;quot;/admin/&amp;quot;, adminIndex)
	...
	
	router.PathPrefix(&amp;quot;/admin&amp;quot;).Handler(negroni.New(
		NewCheckLogin(),
		negroni.Wrap(adminRoutes),
	))
	// /account/login
	router.HandleFunc(&amp;quot;/account/login&amp;quot;, login)
	http.ListenAndServe(&amp;quot;:8080&amp;quot;, router)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;negroni.New(New)eckLogin(),negroni.Wrap(adminRoutes)
这句是进行验证的，具体原理还是需要去研究下，目前不是非常的明白。&lt;/p&gt;

&lt;h2 id=&#34;session的使用比较奇怪-也是需要后续去学习领悟的地方:3689b5210b345acfc0507cf19690ede1&#34;&gt;Session的使用比较奇怪，也是需要后续去学习领悟的地方。&lt;/h2&gt;

&lt;p&gt;除go基本类型外，复杂对象结构存储必须先注册。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import(
        &amp;quot;encoding/gob&amp;quot;
        &amp;quot;github.com/gorilla/sessions&amp;quot;
    )

    type Person struct {
        FirstName   string
        LastName    string
        Email       string
        Age         int
    }

    type M map[string]interface{}

    func init() {

        gob.Register(&amp;amp;Person{})
        gob.Register(&amp;amp;M{})
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang introducing HTTP tracing</title>
      <link>https://qianguozheng.github.io/post/Golang-introducing-HTTP-tracing/</link>
      <pubDate>Fri, 20 Jan 2017 10:09:56 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-introducing-HTTP-tracing/</guid>
      <description>

&lt;h1 id=&#34;介绍:4ce321d90e539aeedd18dbea4986007d&#34;&gt;介绍&lt;/h1&gt;

&lt;p&gt;在Go 1.7我们引入了HTTP跟踪， 用来收集HTTP客户端请求生命周期中详细信息的工作。包在net/http/httptrace. 手机的信息可以用来调试延时问题，服务监控，写适配系统等。&lt;/p&gt;

&lt;h1 id=&#34;http-事件:4ce321d90e539aeedd18dbea4986007d&#34;&gt;HTTP 事件&lt;/h1&gt;

&lt;p&gt;httptrace包提供了许多钩子在HTTP生命周期中收集信息。这些事件包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Connection creation&lt;/li&gt;
&lt;li&gt;Connection reuse&lt;/li&gt;
&lt;li&gt;DNS lookups&lt;/li&gt;
&lt;li&gt;Writing the request to the wire&lt;/li&gt;
&lt;li&gt;Reading the response&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;跟踪事件:4ce321d90e539aeedd18dbea4986007d&#34;&gt;跟踪事件&lt;/h1&gt;

&lt;p&gt;你可以通过放置一个*httptrace.ClientTrace 包含钩子函数在请求的context.Context中来开启http追踪。各种http.RoundTripper实现通过查找上下文的 *httptrace.ClientTrace和调用相关的钩子函数来汇报内部事件&lt;/p&gt;

&lt;p&gt;最终作用于请求的上下文，用户应该将一个 *httptrace.ClientTrace防到请求的上下文在开始请求之前。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;    req, _ := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://example.com&amp;quot;, nil)
    trace := &amp;amp;httptrace.ClientTrace{
        DNSDone: func(dnsInfo httptrace.DNSDoneInfo) {
            fmt.Printf(&amp;quot;DNS Info: %+v\n&amp;quot;, dnsInfo)
        },
        GotConn: func(connInfo httptrace.GotConnInfo) {
            fmt.Printf(&amp;quot;Got Conn: %+v\n&amp;quot;, connInfo)
        },
    }
    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))
    if _, err := http.DefaultTransport.RoundTrip(req); err != nil {
        log.Fatal(err)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在请求流程中，http.DefaultTransport会在事件发生时出发钩子。上面的程序会打印DNS信息当DNS查询完成时。同样的会打印连接信息当链接与请求主机建立连接时&lt;/p&gt;

&lt;h1 id=&#34;使用http-client跟踪:4ce321d90e539aeedd18dbea4986007d&#34;&gt;使用http.Client跟踪&lt;/h1&gt;

&lt;p&gt;跟踪机制设计用来跟踪单个的http.Transport.RoundTrip的声明周期事件。然而，一个客户端可以发起多个round trips来完成HTTP请求。例如，URL重定向，注册的钩子被调用多次当客户端跟踪HTTP重定向，发起多个请求。用户负责识别类似的事件在http.CLient中。下面的程序识别通过httpRoundTripper包裹识别当前的请求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;net/http/httptrace&amp;quot;
)

// transport is an http.RoundTripper that keeps track of the in-flight
// request and implements hooks to report HTTP tracing events.
type transport struct {
    current *http.Request
}

// RoundTrip wraps http.DefaultTransport.RoundTrip to keep track
// of the current request.
func (t *transport) RoundTrip(req *http.Request) (*http.Response, error) {
    t.current = req
    return http.DefaultTransport.RoundTrip(req)
}

// GotConn prints whether the connection has been used previously
// for the current request.
func (t *transport) GotConn(info httptrace.GotConnInfo) {
    fmt.Printf(&amp;quot;Connection reused for %v? %v\n&amp;quot;, t.current.URL, info.Reused)
}

func main() {
    t := &amp;amp;transport{}

    req, _ := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;https://google.com&amp;quot;, nil)
    trace := &amp;amp;httptrace.ClientTrace{
        GotConn: t.GotConn,
    }
    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))

    client := &amp;amp;http.Client{Transport: t}
    if _, err := client.Do(req); err != nil {
        log.Fatal(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序将会跟踪重定向google.com 到www.google.com并打印如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connection reused for https://google.com? false
Connection reused for https://www.google.com/? false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传输在net/http包支持跟踪http/1和http/2&lt;/p&gt;

&lt;p&gt;如果你是一个定制的http.RoundTripper实现作者，你可以通过检查请求上下文并在相应的事件发生时触发钩子函数&lt;/p&gt;

&lt;h1 id=&#34;结论:4ce321d90e539aeedd18dbea4986007d&#34;&gt;结论&lt;/h1&gt;

&lt;p&gt;GO的HTTP跟踪对于那些感兴趣调试HTTP请求延时和些网络外部负载调试工具时。 通过开启这个功能，我们希望可以看到HTTP调试，性能。可视化工具来自社区例如httpstat.&lt;/p&gt;

&lt;p&gt;By Jaana Burcu Dogan&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang recover usage</title>
      <link>https://qianguozheng.github.io/post/Golang-recover-usage/</link>
      <pubDate>Mon, 16 Jan 2017 15:56:55 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-recover-usage/</guid>
      <description>

&lt;h1 id=&#34;golang-panic-recover-usage:4cee95b6a0f7ad978328106e5f21d269&#34;&gt;Golang panic recover usage&lt;/h1&gt;

&lt;h3 id=&#34;brief-introduction:4cee95b6a0f7ad978328106e5f21d269&#34;&gt;Brief Introduction&lt;/h3&gt;

&lt;p&gt;In golang, some abnormal case would cause program crash, but if you want it recover, you need to handle it by hand.&lt;/p&gt;

&lt;p&gt;Below is the simple example of http function use recover to recover from panic caused by peer-end server crash.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;errors&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;strings&amp;quot;
    &amp;quot;time&amp;quot;
)

var err error

func httppost() {
    for {
        fmt.Println(&amp;quot;Cycle...&amp;quot;)
        defer func() {

            if r := recover(); r != nil {

                fmt.Println(&amp;quot;Recovered in testPanic2Error&amp;quot;, r)

                //check exactly what the panic was and create error.
                switch x := r.(type) {
                case string:
                    err = errors.New(x)
                case error:
                    err = x
                default:
                    err = errors.New(&amp;quot;Unknow panic&amp;quot;)
                }
            }
            fmt.Println(err)
            httppost()

        }()
        resp, err := http.Post(&amp;quot;http://127.0.0.1/v3/api/device/vpn&amp;quot;,
            &amp;quot;application/x-www-form-urlencoded&amp;quot;,
            strings.NewReader(&amp;quot;name=qgz&amp;quot;))

        if err != nil {
            fmt.Println(err)
        }

        resp.Body.Close()

        time.Sleep(time.Second * 5)
        fmt.Println(&amp;quot;Cycle...&amp;quot;)
    }
}

func main() {
    httppost()
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>