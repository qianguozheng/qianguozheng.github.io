<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 钱国正博客</title>
    <link>https://qianguozheng.github.io/tags/golang/</link>
    <description>Recent content in Golang on 钱国正博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 23 Feb 2017 17:26:24 +0800</lastBuildDate>
    <atom:link href="https://qianguozheng.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Golang gorilla context doc</title>
      <link>https://qianguozheng.github.io/post/Golang-gorilla-context-doc/</link>
      <pubDate>Thu, 23 Feb 2017 17:26:24 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-gorilla-context-doc/</guid>
      <description>&lt;p&gt;翻译 github.com/gorilla/context/doc.go&lt;/p&gt;

&lt;p&gt;包context存储的值在一个请求的声明周期中是共享的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：gorilla/context, 比&lt;code&gt;context.Context&lt;/code&gt;诞生的早，不能很好的支持&lt;a href=&#34;https://golang.org/pkg/net/http/#Request.WithContext&#34;&gt;&lt;code&gt;http.Request.WithContext&lt;/code&gt;&lt;/a&gt; (引入于Go1.7). 你应该只使用gorilla/context或者换到新的 &lt;code&gt;http.Request.Context()&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;例如， 一个路由可以设置从URL中提取出来的变量， 并且程序的处理者可以访问这些值， 或者这个可以用来存储会话值在请求的最后。还有集中其他的常用方法。&lt;/p&gt;

&lt;p&gt;这个想法是Brad Fitzpatrick在go-nuts的邮件列表中提出的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://groups.google.com/group/golang-nuts/msg/e2d679d303aa5d53
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是基础用法： 首先定义你需要的键。 键的类型是interface{} 所以你可以存储任何类型。&lt;/p&gt;

&lt;p&gt;这里我们定义一个键使用常用的int类型来必买名称冲突：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package foo

import (
    &amp;quot;github.com/gorilla/context&amp;quot;
)

type key int

const MyKey key = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后设置一个变量。 变量是绑定到http.Request对象的， 所以你需要请求的实例来设置值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context.Set(r, MyKey, &amp;quot;bar&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序可以后续使用你提供的键来访问变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MyHandler(w http.ResponseWriter, r *http.Request){
    // val is &amp;quot;bar&amp;quot;.
    val := context.Get(r, foo.MyKey)

    // returns (&amp;quot;bar&amp;quot;, true)
    val, ok := context.GetOk(r, foo.MyKey)
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是最基础的使用方式。 我们在下面讨论一些别的用法。&lt;/p&gt;

&lt;p&gt;所有类型都可以存储在context中。强制使用一种类型， 把键变得私用，并且包裹Get() 和Set()来接受和返回特定类型的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type key int

const mykey key = 0

// GetMyKey returns a value for this package from the request values.
func GetMyKey(r *http.Request) SomeType{
    if rv := context.Get(r, mykey); rv != nil {
        return rv.(SomeType)
    }
    return nil
}

// SetMyKey sets a value for this package in the request values.
func SetMyKey(r *http.Request, val SomeType){
    context.Set(r, mykey, val)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;变量必须在请求的结尾清除，以删除所有存储的值。这个可以在http.Handler中做， 在请求被处理的时候。 只需要调用Clear()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context.Clear(r)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;或者使用 ClearHandler(), 这个方便的包裹来一个http.Handler在请求声明周期的末尾来请求变量&lt;/p&gt;

&lt;p&gt;包gorilla/mux 和gorilla/pat中的路由调用Clear()所以如果你使用他们中的一个，你不需要手动清除上下文。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hugo deploy as submodule on github</title>
      <link>https://qianguozheng.github.io/post/hugo-deploy-as-submodule-on-github/</link>
      <pubDate>Mon, 20 Feb 2017 11:23:14 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/hugo-deploy-as-submodule-on-github/</guid>
      <description>

&lt;p&gt;本Blog就是基于Hugo的，由于担心这次的操作记录丢失，我特意写了这篇博客来记录如何使用这个东西。&lt;/p&gt;

&lt;p&gt;首先根据文档 &lt;a href=&#34;http://www.gohugo.io/tutorials/github-pages-blog/&#34;&gt;gohugo&lt;/a&gt;中的&lt;a href=&#34;http://www.gohugo.io/tutorials/github-pages-blog/#hosting-personal-organization-pages&#34;&gt;第二部分&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;以上文章介绍了如何部署的大概情况，按照步骤来就不会有问题的。&lt;/p&gt;

&lt;p&gt;但是维护起来需要熟悉git submodule的概念与使用，我自以为用过git submodule就安心的使用起来了，可是始终不得其意。
最终还是被我搞定了。&lt;/p&gt;

&lt;p&gt;首先每次下载 &lt;a href=&#34;https://github.com/qianguozheng/blog-hugo.git&#34;&gt;https://github.com/qianguozheng/blog-hugo.git&lt;/a&gt; 的时候，总是没有自动更新&lt;a href=&#34;https://github.com/qianguozheng/qianguozheng.github.io.git&#34;&gt;子模块&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/wangjia55/article/details/24400501&#34;&gt;来自&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后是执行./deploy.sh的时候没有提交子模块。&lt;/p&gt;

&lt;p&gt;这个问题是我偶然发现问题的，我当时并不在master分支，而是特定的分支，导致无法提交。
所以 checkout下，提交就好了&lt;/p&gt;

&lt;p&gt;整个工作流程如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	git clone https://github.com/qianguozheng/blog-hugo.git
	cd blog-hugo;
	#下载子模块
	git submodule update --init --recursive
	
	cd public
	git checkout master
	cd ../
	
	#创建博客
	hugo new post/Golang-test.md
	
	#编辑博客等操作
	...
	
	#提交qianguozheng.github.io.git仓库
	./deploy.sh
	
	#提交blog-hugo仓库
	git add -A
	git commit -m &amp;quot;Update blog&amp;quot;
	git push origin master	

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完美结束&lt;/p&gt;

&lt;h2 id=&#34;结论:792757c8b8fb721dcdc493eb4ef87719&#34;&gt;结论&lt;/h2&gt;

&lt;p&gt;不懂就多做测试，总会解决的&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang mux study</title>
      <link>https://qianguozheng.github.io/post/Golang-mux-study/</link>
      <pubDate>Mon, 20 Feb 2017 11:03:48 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-mux-study/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Golang session problem</title>
      <link>https://qianguozheng.github.io/post/Golang-session-problem/</link>
      <pubDate>Sun, 19 Feb 2017 21:03:06 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-session-problem/</guid>
      <description>

&lt;h1 id=&#34;golang-session-using-problem:3689b5210b345acfc0507cf19690ede1&#34;&gt;Golang Session using problem&lt;/h1&gt;

&lt;p&gt;以前从事嵌入式工作，没有做过多用户的处理，比如web服务器上后台管理人员与普通用户的区别。&lt;/p&gt;

&lt;p&gt;最近自己在写一个认证服务器的简单管理功能，想优化下就增加了admin管理权限。&lt;/p&gt;

&lt;h2 id=&#34;初步设计:3689b5210b345acfc0507cf19690ede1&#34;&gt;初步设计&lt;/h2&gt;

&lt;p&gt;通过通过mux来管理路由。然后在访问/admin/路径下的API时需要检测是否登陆。&lt;/p&gt;

&lt;h2 id=&#34;实现中遇到的问题:3689b5210b345acfc0507cf19690ede1&#34;&gt;实现中遇到的问题&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;mux的具体实现不知道，需要进一步了解，今后的文章要分析透彻。&lt;/li&gt;
&lt;li&gt;google了很多的管理登陆的文章，发现都是需要在处理的API内部做判断登陆，这点我感觉繁琐了，增加一个中间件不就好了吗，但是怎么增加是一个问题。&lt;/li&gt;
&lt;li&gt;另外一个就是session的使用中遇到的了，我明明增加了session，但是就是没有收到数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;中间件验证登陆解决方案:3689b5210b345acfc0507cf19690ede1&#34;&gt;中间件验证登陆解决方案&lt;/h2&gt;

&lt;p&gt;通过mux建立路由，所有访问/admin/目录下的请求需要先验证是否登陆，即判断是否存在session。&lt;/p&gt;

&lt;p&gt;只需要&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    router := mux.NewRouter()
	adminRoutes := mux.NewRouter()

	router.HandleFunc(&amp;quot;/&amp;quot;, index)

	adminRoutes.HandleFunc(&amp;quot;/admin/&amp;quot;, adminIndex)
	...
	
	router.PathPrefix(&amp;quot;/admin&amp;quot;).Handler(negroni.New(
		NewCheckLogin(),
		negroni.Wrap(adminRoutes),
	))
	// /account/login
	router.HandleFunc(&amp;quot;/account/login&amp;quot;, login)
	http.ListenAndServe(&amp;quot;:8080&amp;quot;, router)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;negroni.New(New)eckLogin(),negroni.Wrap(adminRoutes)
这句是进行验证的，具体原理还是需要去研究下，目前不是非常的明白。&lt;/p&gt;

&lt;h2 id=&#34;session的使用比较奇怪-也是需要后续去学习领悟的地方:3689b5210b345acfc0507cf19690ede1&#34;&gt;Session的使用比较奇怪，也是需要后续去学习领悟的地方。&lt;/h2&gt;

&lt;p&gt;除go基本类型外，复杂对象结构存储必须先注册。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import(
        &amp;quot;encoding/gob&amp;quot;
        &amp;quot;github.com/gorilla/sessions&amp;quot;
    )

    type Person struct {
        FirstName   string
        LastName    string
        Email       string
        Age         int
    }

    type M map[string]interface{}

    func init() {

        gob.Register(&amp;amp;Person{})
        gob.Register(&amp;amp;M{})
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang introducing HTTP tracing</title>
      <link>https://qianguozheng.github.io/post/Golang-introducing-HTTP-tracing/</link>
      <pubDate>Fri, 20 Jan 2017 10:09:56 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-introducing-HTTP-tracing/</guid>
      <description>

&lt;h1 id=&#34;介绍:4ce321d90e539aeedd18dbea4986007d&#34;&gt;介绍&lt;/h1&gt;

&lt;p&gt;在Go 1.7我们引入了HTTP跟踪， 用来收集HTTP客户端请求生命周期中详细信息的工作。包在net/http/httptrace. 手机的信息可以用来调试延时问题，服务监控，写适配系统等。&lt;/p&gt;

&lt;h1 id=&#34;http-事件:4ce321d90e539aeedd18dbea4986007d&#34;&gt;HTTP 事件&lt;/h1&gt;

&lt;p&gt;httptrace包提供了许多钩子在HTTP生命周期中收集信息。这些事件包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Connection creation&lt;/li&gt;
&lt;li&gt;Connection reuse&lt;/li&gt;
&lt;li&gt;DNS lookups&lt;/li&gt;
&lt;li&gt;Writing the request to the wire&lt;/li&gt;
&lt;li&gt;Reading the response&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;跟踪事件:4ce321d90e539aeedd18dbea4986007d&#34;&gt;跟踪事件&lt;/h1&gt;

&lt;p&gt;你可以通过放置一个*httptrace.ClientTrace 包含钩子函数在请求的context.Context中来开启http追踪。各种http.RoundTripper实现通过查找上下文的 *httptrace.ClientTrace和调用相关的钩子函数来汇报内部事件&lt;/p&gt;

&lt;p&gt;最终作用于请求的上下文，用户应该将一个 *httptrace.ClientTrace防到请求的上下文在开始请求之前。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;    req, _ := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://example.com&amp;quot;, nil)
    trace := &amp;amp;httptrace.ClientTrace{
        DNSDone: func(dnsInfo httptrace.DNSDoneInfo) {
            fmt.Printf(&amp;quot;DNS Info: %+v\n&amp;quot;, dnsInfo)
        },
        GotConn: func(connInfo httptrace.GotConnInfo) {
            fmt.Printf(&amp;quot;Got Conn: %+v\n&amp;quot;, connInfo)
        },
    }
    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))
    if _, err := http.DefaultTransport.RoundTrip(req); err != nil {
        log.Fatal(err)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在请求流程中，http.DefaultTransport会在事件发生时出发钩子。上面的程序会打印DNS信息当DNS查询完成时。同样的会打印连接信息当链接与请求主机建立连接时&lt;/p&gt;

&lt;h1 id=&#34;使用http-client跟踪:4ce321d90e539aeedd18dbea4986007d&#34;&gt;使用http.Client跟踪&lt;/h1&gt;

&lt;p&gt;跟踪机制设计用来跟踪单个的http.Transport.RoundTrip的声明周期事件。然而，一个客户端可以发起多个round trips来完成HTTP请求。例如，URL重定向，注册的钩子被调用多次当客户端跟踪HTTP重定向，发起多个请求。用户负责识别类似的事件在http.CLient中。下面的程序识别通过httpRoundTripper包裹识别当前的请求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;net/http/httptrace&amp;quot;
)

// transport is an http.RoundTripper that keeps track of the in-flight
// request and implements hooks to report HTTP tracing events.
type transport struct {
    current *http.Request
}

// RoundTrip wraps http.DefaultTransport.RoundTrip to keep track
// of the current request.
func (t *transport) RoundTrip(req *http.Request) (*http.Response, error) {
    t.current = req
    return http.DefaultTransport.RoundTrip(req)
}

// GotConn prints whether the connection has been used previously
// for the current request.
func (t *transport) GotConn(info httptrace.GotConnInfo) {
    fmt.Printf(&amp;quot;Connection reused for %v? %v\n&amp;quot;, t.current.URL, info.Reused)
}

func main() {
    t := &amp;amp;transport{}

    req, _ := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;https://google.com&amp;quot;, nil)
    trace := &amp;amp;httptrace.ClientTrace{
        GotConn: t.GotConn,
    }
    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))

    client := &amp;amp;http.Client{Transport: t}
    if _, err := client.Do(req); err != nil {
        log.Fatal(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序将会跟踪重定向google.com 到www.google.com并打印如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connection reused for https://google.com? false
Connection reused for https://www.google.com/? false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传输在net/http包支持跟踪http/1和http/2&lt;/p&gt;

&lt;p&gt;如果你是一个定制的http.RoundTripper实现作者，你可以通过检查请求上下文并在相应的事件发生时触发钩子函数&lt;/p&gt;

&lt;h1 id=&#34;结论:4ce321d90e539aeedd18dbea4986007d&#34;&gt;结论&lt;/h1&gt;

&lt;p&gt;GO的HTTP跟踪对于那些感兴趣调试HTTP请求延时和些网络外部负载调试工具时。 通过开启这个功能，我们希望可以看到HTTP调试，性能。可视化工具来自社区例如httpstat.&lt;/p&gt;

&lt;p&gt;By Jaana Burcu Dogan&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang recover usage</title>
      <link>https://qianguozheng.github.io/post/Golang-recover-usage/</link>
      <pubDate>Mon, 16 Jan 2017 15:56:55 +0800</pubDate>
      
      <guid>https://qianguozheng.github.io/post/Golang-recover-usage/</guid>
      <description>

&lt;h1 id=&#34;golang-panic-recover-usage:4cee95b6a0f7ad978328106e5f21d269&#34;&gt;Golang panic recover usage&lt;/h1&gt;

&lt;h3 id=&#34;brief-introduction:4cee95b6a0f7ad978328106e5f21d269&#34;&gt;Brief Introduction&lt;/h3&gt;

&lt;p&gt;In golang, some abnormal case would cause program crash, but if you want it recover, you need to handle it by hand.&lt;/p&gt;

&lt;p&gt;Below is the simple example of http function use recover to recover from panic caused by peer-end server crash.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;errors&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;strings&amp;quot;
    &amp;quot;time&amp;quot;
)

var err error

func httppost() {
    for {
        fmt.Println(&amp;quot;Cycle...&amp;quot;)
        defer func() {

            if r := recover(); r != nil {

                fmt.Println(&amp;quot;Recovered in testPanic2Error&amp;quot;, r)

                //check exactly what the panic was and create error.
                switch x := r.(type) {
                case string:
                    err = errors.New(x)
                case error:
                    err = x
                default:
                    err = errors.New(&amp;quot;Unknow panic&amp;quot;)
                }
            }
            fmt.Println(err)
            httppost()

        }()
        resp, err := http.Post(&amp;quot;http://127.0.0.1/v3/api/device/vpn&amp;quot;,
            &amp;quot;application/x-www-form-urlencoded&amp;quot;,
            strings.NewReader(&amp;quot;name=qgz&amp;quot;))

        if err != nil {
            fmt.Println(err)
        }

        resp.Body.Close()

        time.Sleep(time.Second * 5)
        fmt.Println(&amp;quot;Cycle...&amp;quot;)
    }
}

func main() {
    httppost()
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>